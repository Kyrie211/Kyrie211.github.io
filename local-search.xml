<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring基础（三）AOP</title>
    <link href="/2020/08/12/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89AOP/"/>
    <url>/2020/08/12/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="1-AOP-前奏"><a href="#1-AOP-前奏" class="headerlink" title="1 AOP 前奏"></a>1 AOP 前奏</h2><h3 id="1-1-引子"><a href="#1-1-引子" class="headerlink" title="1.1 引子"></a>1.1 引子</h3><blockquote><p>数学计算器</p><p>要求 :<br> ①执行加减乘除运算<br> ②日志：在程序执行期间追踪正在发生的活动<br> ③验证：希望计算器只能处理正数的运算</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/12/ajn5TJ.png" srcset="/img/loading.gif" alt="数学计算器"></p><h3 id="1-2-实现方式"><a href="#1-2-实现方式" class="headerlink" title="1.2 实现方式"></a>1.2 实现方式</h3><ol><li><p>常规实现<br>在各个方法体中，直接插入代码（硬编码方式）</p><p>可想而知，这种方式，容易造成代码混乱、代码分散，之后编码越发复制，维护成本逐渐变大。</p></li><li><p>动态代理</p></li></ol><blockquote><p>代理设计模式的原理：</p><p>使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p><p>代理对象，可以实现对目标方法功能上的增强操作。从而可以不用硬编码的方式，就可以添加日志功能。</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/12/ajKEgx.png" srcset="/img/loading.gif" alt="日志代理"></p><p>值得一提的是，Spring的AOP技术来源就是动态代理技术，不过动态代理相对来说，编码还是稍微有些难的，而Spring的AOP技术，操作起来就很简单。</p><hr><h2 id="2-AOP-概述"><a href="#2-AOP-概述" class="headerlink" title="2 AOP 概述"></a>2 AOP 概述</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>●AOP(Aspect-Oriented Programming， 面向切面编程)：是一种新的方法论，是对传统<br>OOP(Object-Oriented Programming，面向对象编程)的补充。</p><p>●AOP 编程操作的主要对象是切面(aspect)，而切面 模块化横切关注点。</p><p>●在应用 AOP 编程时，仍然需要定义公共功能，但可以明确的定义这个功能应用在哪<br>里，以什么方式应用，并且不必修改受影响的类。这样一来横切关注点就被模块化到特<br>殊的类里——这样的类我们通常称之为“切面”。</p><p>●AOP 的好处：</p><blockquote><p>o 每个事物逻辑位于一个位置，代码不分散，便于维护和升级<br>o 业务模块更简洁，只包含核心业务代码</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/12/ajKOde.png" srcset="/img/loading.gif" alt="数学计算器AOP"></p><h3 id="2-2-AOP-术语"><a href="#2-2-AOP-术语" class="headerlink" title="2.2 AOP 术语"></a>2.2 AOP 术语</h3><ul><li><p>横切关注点<br>从每个方法中抽取出来的同一类非核心业务。</p></li><li><p>切面(Aspect)<br>封装横切关注点信息的类，每个关注点体现为一个通知方法。</p></li><li><p>通知(Advice)<br>切面必须要完成的各个具体工作</p></li><li><p>目标(Target)<br>被通知的对象</p></li><li><p>代理(Proxy)<br>向目标对象应用通知之后创建的代理对象</p></li><li><p>连接点(Joinpoint)<br>横切关注点在程序代码中的具体体现，对应程序执行的某个特定位置。<br>例如：类某个方法调用前、调用后、方法捕获到异常后等。<br>在应用程序中可以使用横纵两个坐标来定位一个具体的连接点：<br><img src="https://s1.ax1x.com/2020/08/12/ajMhm8.png" srcset="/img/loading.gif" alt="连接点"></p></li><li><p>切入点(pointcut)：<br>定位连接点的方式。每个类的方法中都包含多个连接点，所以连接点是类中客观 存在的事物。</p></li></ul><blockquote><p>如果把连接点看作数据库中的记录，那么切入点就是查询条件 —— AOP 可 以 通 过 切 入 点 定 位 到 特 定 的 连 接 点 。</p></blockquote><h3 id="2-3-AspectJ"><a href="#2-3-AspectJ" class="headerlink" title="2.3 AspectJ"></a>2.3 AspectJ</h3><blockquote><p>AspectJ：Java 社区里最完整最流行的 AOP 框架。<br>在 Spring2.0 以上版本中，可以使用基于 AspectJ 注解或基于 XML 配置的 AOP。</p></blockquote><ol><li>在 Spring 中启用 AspectJ 注解支持</li></ol><p>导入 JAR 包</p><pre><code class="hljs css">● <span class="hljs-selector-tag">aopalliance</span><span class="hljs-selector-class">.jar</span>● <span class="hljs-selector-tag">aspectj</span><span class="hljs-selector-class">.weaver</span><span class="hljs-selector-class">.jar</span>● <span class="hljs-selector-tag">spring-aspects</span><span class="hljs-selector-class">.jar</span></code></pre><p>引入 aop 名称空间<br><img src="https://s1.ax1x.com/2020/08/12/ajQf3R.png" srcset="/img/loading.gif" alt="aop名称空间"></p><p>配置注解驱动</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><span class="hljs-comment">&lt;!-- 当 Spring IOC 容器侦测到 bean 配置文件中的&lt;aop:aspectj-autoproxy&gt;元素时，</span><span class="hljs-comment">会自动为与 AspectJ 切面匹配的 bean 创建代理 --&gt;</span></code></pre><p>用 AspectJ 注解声明切面</p><blockquote><p>①要在 Spring 中声明 AspectJ 切面，只需要在 IOC 容器中将切面声明为 bean 实例。 </p><p>②当在 Spring IOC容器中初始化 AspectJ 切面之后，Spring IOC 容器就会为那些与 AspectJ 切面相匹配的<br>bean 创建代理。 </p><p>③在AspectJ 注解中，切面只是一个带有@Aspect 注解的 Java 类，它往往要包含很 多通知。 </p><p>④通知是标注有某种注解的简单的Java 方法。</p></blockquote><ul><li><p>AspectJ 支持 5 种类型的通知注解：</p><pre><code class="hljs less"><span class="hljs-variable">@Before</span>：前置通知，在方法执行之前执行<span class="hljs-variable">@After</span>：后置通知，在方法执行之后执行<span class="hljs-variable">@AfterRunning</span>：返回通知，在方法返回结果之后执行<span class="hljs-variable">@AfterThrowing</span>：返回通知，在方法抛出异常之后执行<span class="hljs-variable">@Around</span>：环绕通知，围绕着方法执行 (环绕通知就相当于一个动态代理， 具有上面注解的所有功能)</code></pre></li><li><p>动态代理处理日志<br>通常的，我们在为某个方法添加日志操作时，使用动态代理会有：</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 动态代理的invoke方法 --&gt;</span></span><span class="xml">try </span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">    // 前置通知（或前置增强）</span><span class="hljs-template-variable">    目标方法执行</span><span class="hljs-template-variable">    // 返回通知</span><span class="hljs-template-variable">&#125;</span><span class="xml"> catch(Exception e)</span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">    // 返回通知</span><span class="hljs-template-variable">&#125;</span><span class="xml"> finally </span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">    // 后置通知</span><span class="hljs-template-variable">&#125;</span></code></pre></li><li><p>使用AspectJ注解实现日志<br>定义切面类<br><img src="https://s1.ax1x.com/2020/08/12/aj1x78.png" srcset="/img/loading.gif" alt="切面类"></p></li></ul><blockquote><p>通过Spring AOP实现日志（不止日志）就显得十分简单了</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础（二）IOC</title>
    <link href="/2020/08/07/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89IOC/"/>
    <url>/2020/08/07/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89IOC/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC容器及Bean的配置"><a href="#IOC容器及Bean的配置" class="headerlink" title="IOC容器及Bean的配置"></a>IOC容器及Bean的配置</h1><h2 id="1-IOC和DI"><a href="#1-IOC和DI" class="headerlink" title="1 IOC和DI"></a>1 IOC和DI</h2><h3 id="1-1-IOC-Inversion-of-Control-：-反转控制。"><a href="#1-1-IOC-Inversion-of-Control-：-反转控制。" class="headerlink" title="1.1 IOC(Inversion of Control)： 反转控制。"></a>1.1 IOC(Inversion of Control)： 反转控制。</h3><blockquote><p>在应用程序中的组件需要获取资源时，传统的方式是组件主动的从容器中获取所需<br>要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，<br>增加了学习成本，同时降低了开发效率。<br>反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取<br>方向——改由容器主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创<br>建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发<br>的效率。这种行为也称为查找的被动形式。</p></blockquote><h3 id="1-2-DI-Dependency-Injection-：-依赖注入。"><a href="#1-2-DI-Dependency-Injection-：-依赖注入。" class="headerlink" title="1.2 DI(Dependency Injection)： 依赖注入。"></a>1.2 DI(Dependency Injection)： 依赖注入。</h3><blockquote><p>IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如：setter 方法)接受<br>来自于容器的资源注入。相对于 IOC 而言，这种表述更直接。</p></blockquote><h3 id="1-3-IOC-容器在-Spring-中的实现"><a href="#1-3-IOC-容器在-Spring-中的实现" class="headerlink" title="1.3 IOC 容器在 Spring 中的实现"></a>1.3 IOC 容器在 Spring 中的实现</h3><blockquote><p>[1]在通过 IOC 容器读取 Bean 的实例之前，需要先将 IOC 容器本身实例化。<br>[2]Spring 提供了 IOC 容器的两种实现方式</p><blockquote><p>(1)BeanFactory：IOC 容器的基本实现，是 Spring 内部的基础设施，是面向 Spring<br>本身的，不是提供给开发人员使用的。<br>(2)ApplicationContext：BeanFactory 的子接口，提供了更多高级特性。面向 Spring<br>的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</p></blockquote></blockquote><p><img src="https://s1.ax1x.com/2020/08/12/ajA7WT.png" srcset="/img/loading.gif" alt="ApplicationContext"></p><h3 id="1-4-ApplicationContext-的主要实现类"><a href="#1-4-ApplicationContext-的主要实现类" class="headerlink" title="1.4 ApplicationContext 的主要实现类"></a>1.4 ApplicationContext 的主要实现类</h3><p>[1]ClassPathXmlApplicationContext：对应类路径下的 XML 格式的配置文件</p><p>[2]FileSystemXmlApplicationContext：对应文件系统中的 XML 格式的配置文件</p><p>[3]在初始化时就创建单例的 bean，也可以通过配置的方式指定创建的 Bean 是多实<br>例的。</p><h3 id="1-5-ConfigurableApplicationContext"><a href="#1-5-ConfigurableApplicationContext" class="headerlink" title="1.5 ConfigurableApplicationContext"></a>1.5 ConfigurableApplicationContext</h3><p>[1]是 ApplicationContext 的子接口，包含一些扩展方法</p><p>[2]refresh()和 close()让 ApplicationContext 具有启动、关闭和刷新上下文的能力。</p><h3 id="1-6-WebApplicationContext"><a href="#1-6-WebApplicationContext" class="headerlink" title="1.6 WebApplicationContext"></a>1.6 WebApplicationContext</h3><p>专门为 WEB 应用而准备的，它允许从相对于 WEB 根目录的路径中完成初始化工作</p><hr><h2 id="2-通过类型获取-bean"><a href="#2-通过类型获取-bean" class="headerlink" title="2 通过类型获取 bean"></a>2 通过类型获取 bean</h2><p>从 IOC 容器中获取 bean 时，可以通过 bean 的类型获取。<br>但如果同一个类型的 bean 在 XML 文件中配置了多个，则获取时会抛出异常，所以同一个类型的 bean 在容器中必须是唯一的。</p><pre><code class="hljs coffeescript">HelloWorld helloWorld = ioc.getBean(HelloWorld. <span class="hljs-class"><span class="hljs-keyword">class</span>);</span></code></pre><h2 id="3-给-bean-的属性赋值"><a href="#3-给-bean-的属性赋值" class="headerlink" title="3 给 bean 的属性赋值"></a>3 给 bean 的属性赋值</h2><h3 id="3-1-赋值的途经"><a href="#3-1-赋值的途经" class="headerlink" title="3.1 赋值的途经"></a>3.1 赋值的途经</h3><p>①通过 bean 的 setXxx()方法赋值</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Book"</span> &gt;</span><span class="hljs-comment">&lt;!-- property赋值方式，是通过Book的Setter方法实现的 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"studentId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1001"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>②通过 bean 的构造器赋值</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Book"</span> &gt;</span><span class="hljs-comment">&lt;!-- Book中得有一个对应参数的构造器声明 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>= <span class="hljs-string">"10010"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>= <span class="hljs-string">"Book01"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>= <span class="hljs-string">"Author01"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>= <span class="hljs-string">"20.2"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span> &gt;</span></code></pre><p>特别的，对于这种方式，我们还可以</p><ul><li>通过索引值指定参数位置<pre><code class="hljs pgsql">&lt;bean id="book" <span class="hljs-keyword">class</span>="com.kyrie.entity.Book" &gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "10010" <span class="hljs-keyword">index</span> ="0"/&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "Book01" <span class="hljs-keyword">index</span> ="1"/&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "Author01" <span class="hljs-keyword">index</span> ="2"/&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "20.2" <span class="hljs-keyword">index</span> ="3"/&gt;&lt;/bean &gt;</code></pre></li></ul><ul><li>通过类型不同区分重载的构造器<pre><code class="hljs pgsql">&lt;bean id="book" <span class="hljs-keyword">class</span>="com.kyrie.entity.Book" &gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "10010" <span class="hljs-keyword">index</span> ="0" <span class="hljs-keyword">type</span>="java.lang.Integer" /&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "Book01" <span class="hljs-keyword">index</span> ="1" <span class="hljs-keyword">type</span>="java.lang.String" /&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "Author01" <span class="hljs-keyword">index</span> ="2" <span class="hljs-keyword">type</span>="java.lang.String" /&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "20.2" <span class="hljs-keyword">index</span> ="3" <span class="hljs-keyword">type</span>="java.lang.Double" /&gt;&lt;/bean &gt;</code></pre></li></ul><p>③给 bean 的级联属性赋值</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"action"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.bean.Action"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"service"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"service"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 设置级联属性(了解) --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"service.dao.dataSource"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"DBCP"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>④p 名称空间</p><blockquote><p>为了简化 XML 文件的配置，越来越多的 XML 文件采用属性而非子元素配置信息。<br>Spring 从 2.5 版本开始引入了一个新的 p 命名空间，可以通过<bean>元素属性的方式配置 Bean 的属性。<br>使用 p 命名空间后，基于 XML 的配置方式将进一步简化。</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这种方式是将内部标签 转成了 属性 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span></span><span class="hljs-tag"><span class="hljs-attr">id</span>=<span class="hljs-string">"studentSuper"</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"com.atguigu.helloworld.bean.Student"</span></span><span class="hljs-tag"><span class="hljs-attr">p:studentId</span>=<span class="hljs-string">"2002"</span> <span class="hljs-attr">p:stuName</span>=<span class="hljs-string">"Jerry2016"</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">"18"</span> /&gt;</span></code></pre><h3 id="3-2-赋值时可以使用的值"><a href="#3-2-赋值时可以使用的值" class="headerlink" title="3.2 赋值时可以使用的值"></a>3.2 赋值时可以使用的值</h3><p>①字面量</p><blockquote><p>[1]可以使用字符串表示的值，可以通过 value 属性或 value 子节点的方式指定<br>[2]基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式<br>[3]若字面值中包含特殊字符，可以使用<![CDATA[]]>把字面值包裹起来</p></blockquote><p>②null 值</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 如果需要赋值为null，则可以使用&lt;null&gt;标签 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>= <span class="hljs-string">"bookName"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre><p>③外部已声明的 bean</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shop"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Shop"</span> &gt;</span><span class="hljs-comment">&lt;!-- ref引用--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>= <span class="hljs-string">"book"</span> <span class="hljs-attr">ref</span> =<span class="hljs-string">"book"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span> &gt;</span></code></pre><p>④内部 bean</p><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">"shop2"</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"com.kyrie.entity.Shop"</span> &gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>= <span class="hljs-string">"book"</span>&gt;    &lt;bean <span class="hljs-built_in">class</span>= <span class="hljs-string">"com.kyrie.entity.Book"</span> &gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>= <span class="hljs-string">"bookId"</span> value =<span class="hljs-string">"1000"</span>/&gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>= <span class="hljs-string">"bookName"</span> value=<span class="hljs-string">"innerBook"</span> /&gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>= <span class="hljs-string">"author"</span> value=<span class="hljs-string">"innerAuthor"</span> /&gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>= <span class="hljs-string">"price"</span> value =<span class="hljs-string">"50"</span>/&gt;    &lt;/bean&gt;    &lt;/<span class="hljs-keyword">property</span>&gt;&lt;/bean &gt;</code></pre><p>注意：</p><ul><li><p>内部 bean 不能使用在任何其他地方</p></li><li><p>当 bean 实例仅仅给一个特定的属性使用时，可以将其声明为内部 bean。内部bean 声明直接包含在<property>或<constructor-arg>元素里，不需要设置任何 id或 name 属性</p></li></ul><h3 id="3-3-集合属性赋值"><a href="#3-3-集合属性赋值" class="headerlink" title="3.3 集合属性赋值"></a>3.3 集合属性赋值</h3><p>在 Spring 中可以通过一组内置的 XML 标签来配置集合属性，例如：<list>，<set><br>或<map>。</p><p>①数组和 List</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shop"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Shop"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>= <span class="hljs-string">"categoryList"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 以字面量为值的 List 集合 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> 历史<span class="hljs-tag">&lt;/<span class="hljs-name">value</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> 军事<span class="hljs-tag">&lt;/<span class="hljs-name">value</span> &gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>= <span class="hljs-string">"bookList"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 以 bean 的引用为值的 List 集合 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>= <span class="hljs-string">"book01"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>= <span class="hljs-string">"book02"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span> &gt;</span></code></pre><p>配置 java.util.Set 需要使用<set>标签，定义的方法与 List 一样。</p><p>②Map</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cup"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Cup"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"bookMap"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>bookKey01<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book01"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>bookKey02<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book02"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>③Properties<br>使用<props>定义 java.util.Properties，该标签使用多个<prop>作为子标签。每个<prop>标签必须定义 key 属性</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.atguigu.spring.bean.DataSource"</span></span><span class="hljs-tag"><span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"properties"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"userName"</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"password"</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"url"</span>&gt;</span>jdbc:mysql:///test<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>④集合类型的 bean</p><blockquote><p>如果只能将集合对象配置在某个 bean 内部，则这个集合的配置将不能重用。<br>我们需要将集合 bean 的配置拿到外面，供其他 bean 引用。</p></blockquote><p>配置集合类型的 bean 需要引入 util 名称空间</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bookList"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book01"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book02"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book03"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book04"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book05"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"categoryList"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>编程<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>极客<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>相声<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>评书<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span></code></pre><hr><h2 id="4-通过工厂创建-bean"><a href="#4-通过工厂创建-bean" class="headerlink" title="4 通过工厂创建 bean"></a>4 通过工厂创建 bean</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://s1.ax1x.com/2020/08/12/ajEF6e.png" srcset="/img/loading.gif" alt="FactoryBean"></h2><h2 id="5-bean-的高级配置"><a href="#5-bean-的高级配置" class="headerlink" title="5 bean 的高级配置"></a>5 bean 的高级配置</h2><h3 id="5-1-配置信息的继承"><a href="#5-1-配置信息的继承" class="headerlink" title="5.1 配置信息的继承"></a>5.1 配置信息的继承</h3><p>①背景<br>查看下面两个 Employee 的配置，其中 dept 属性是重复的。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dept"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Department"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"deptId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"100"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"deptName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"IT"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emp01"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Employee"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1001"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Tom"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"20"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 重复的属性值 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"detp"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dept"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emp02"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Employee"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1002"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Jerry"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"25"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 重复的属性值 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"detp"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dept"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>②配置信息的继承</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 以emp01作为父bean，继承后可以省略公共属性值的配置 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emp02"</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"emp01"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1002"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Jerry"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"25"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>Note：</p><ul><li>Spring 允许继承 bean 的配置，被继承的 bean 称为父 bean。继承这个父 bean<br>的 bean 称为子 bean。</li><li>子 bean 从父 bean 中继承配置，包括 bean 的属性配置。</li><li>子 bean 也可以覆盖从父 bean 继承过来的配置</li></ul><p>③补充说明</p><ol><li>父 bean 可以作为配置模板，也可以作为 bean 实例。若只想把父 bean 作为模<br>板，可以设置<bean>的 abstract 属性为 true，这样 Spring 将不会实例化这个 bean。</li><li>如果一个 bean 的 class 属性没有指定，则必须是抽象 bean。</li><li>并不是<bean>元素里的所有属性都会被继承。比如：autowire，abstract 等。 也可以忽略父 bean 的 class<br>属性，让子 bean 指定自己的类，而共享相同的属 性配置。但此时 abstract 必须设为 true。</li></ol><h3 id="5-2-bean-之间的依赖"><a href="#5-2-bean-之间的依赖" class="headerlink" title="5.2 bean 之间的依赖"></a>5.2 bean 之间的依赖</h3><p>有的时候创建一个 bean 的时候需要保证另外一个 bean 也被创建，这时我们称前<br>面的 bean 对后面的 bean 有依赖。</p><p>这里需要注意的是依赖关系不等于引用关系，只是一种前后关系。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- depends-on: 此时emp03在dept后在IOC容器中创建 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emp03"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Employee"</span></span><span class="hljs-tag"><span class="hljs-attr">depends-on</span>=<span class="hljs-string">"dept"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1003"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Kate"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"21"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h3 id="5-3-bean-的作用域"><a href="#5-3-bean-的作用域" class="headerlink" title="5.3 bean 的作用域"></a>5.3 bean 的作用域</h3><p>在 Spring 中，可以在<bean>元素的 scope 属性里设置 bean 的作用域，以决定<br>这个 bean 是单实例的还是多实例的。</p><blockquote><p>默认情况下，Spring 只为每个在 IOC 容器里声明的 bean 创建唯一一个实例，<br>整个 IOC 容器范围内都能共享该实例：<br>所有后续的 getBean()调用和 bean 引用都将返回这个唯一的 bean 实例。该作用域被称为 singleton，它是所有 bean 的默认作用域。</p></blockquote><p>当 bean 的作用域为单例时，Spring 会在 IOC 容器对象创建时就创建 bean 的对<br>象实例。而当 bean 的作用域为 prototype 时，IOC 容器在获取 bean 的实例时创建<br>bean 的实例对象。</p><p><img src="https://s1.ax1x.com/2020/08/12/ajAvwR.png" srcset="/img/loading.gif" alt="bean生命周期"></p><h3 id="5-4-bean-的生命周期"><a href="#5-4-bean-的生命周期" class="headerlink" title="5.4 bean 的生命周期"></a>5.4 bean 的生命周期</h3><h3 id="5-5-引用外部属性文件"><a href="#5-5-引用外部属性文件" class="headerlink" title="5.5 引用外部属性文件"></a>5.5 引用外部属性文件</h3><blockquote><p>当 bean 的配置信息逐渐增多时，查找和修改一些 bean 的配置信息就变得愈加困<br>难。这时可以将一部分信息提取到 bean 配置文件的外部，以 properties 格式的属<br>性文件保存起来，同时在 bean 的配置文件中引用 properties 属性文件中的内容，<br>从而实现一部分属性值在发生变化时仅修改 properties 属性文件即可。这种技术<br>多用于连接数据库的基本信息的配置。</p></blockquote><p>①直接配置</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 直接配置 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql:///test"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>②创建 properties 属性文件</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- jdbc.properties --&gt;</span>prop.userName=rootprop.password=rootprop.url=jdbc:mysql:///testprop.driverClass=com.mysql.jdbc.Driver</code></pre><p>③引入 context 名称空间</p><blockquote><p>在头文件中，引入该名称空间<br>这个在eclipse中需要自行操作， IDEA中自动可用。</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/12/ajAxT1.png" srcset="/img/loading.gif" alt="context名称空间"></p><p>④指定 properties 属性文件的位置</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Spring配置文件中 --&gt;</span><span class="hljs-comment">&lt;!-- 指定properties属性文件的位置 --&gt;</span><span class="hljs-comment">&lt;!-- classpath:xxx 表示属性文件位于类路径下 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:jdbc.properties"</span>/&gt;</span></code></pre><p>⑤从 properties 属性文件中引入属性值</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 从properties属性文件中引入属性值 --&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span></span></span><span class="xml">class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;prop.userName&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;prop.password&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;prop.url&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;prop.driverClass&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span></code></pre><h3 id="5-6-自动装配"><a href="#5-6-自动装配" class="headerlink" title="5.6 自动装配"></a>5.6 自动装配</h3><p>①自动装配的概念</p><blockquote><p>[1]手动装配：以 value 或 ref 的方式 明确指定属性值都是手动装配。<br>[2]自动装配：根据指定的装配规则， 不需要明确指定，Spring 自动将匹配的<br>属性值入 注入 bean 中。</p></blockquote><p>②装配模式</p><blockquote><p>[1]根据 类型自动装配：将类型匹配的 bean 作为属性注入到另一个 bean 中。 若 IOC 容器中有多个与目标 bean 类型一致的<br>bean，Spring 将无法判定哪个 bean 最合适该属性，所以不能执行自动装配</p><p>[2]根据 名称自动装配：必须将目标 bean 的名称和属性名设置的完全相同</p><p>[3]通过构造器自动装配：当 bean 中存在多个构造器时，此种自动装配方式 将会很复杂。不推荐使用。</p></blockquote><p>③选用建议</p><blockquote><p>相对于使用注解的方式实现的自动装配，在 XML 文档中进行的自动装配略显<br>笨拙，在项目中更多的使用<strong>注解</strong>的方式实现。</p></blockquote><hr><h2 id="6-通过注解配置-bean"><a href="#6-通过注解配置-bean" class="headerlink" title="6 通过注解配置 bean"></a>6 通过注解配置 bean</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><blockquote><p>相对于 XML 方式而言，通过注解的方式配置 bean 更加简洁和优雅，而且和 MVC<br>组件化开发的理念十分契合，是开发中常用的使用方式。</p></blockquote><h3 id="6-2-Spring相关注解"><a href="#6-2-Spring相关注解" class="headerlink" title="6.2 Spring相关注解"></a>6.2 Spring相关注解</h3><blockquote><p>①普通组件：@Component 标识一个受 Spring IOC 容器管理的组件</p><p>②持久化层组件：@Respository 标识一个受 Spring IOC 容器管理的持久化层组件</p><p>③业务逻辑层组件：@Service 标识一个受 Spring IOC 容器管理的业务逻辑层组件</p><p>④表述层控制器组件：@Controller 标识一个受 Spring IOC 容器管理的表述层控制器组件</p><p>⑤组件命名规则 [1]默认情况：使用组件的简单类名首字母小写后得到的字符串作为 bean 的 id [2]使用组件注解的 value<br>属性指定 bean 的 id</p></blockquote><p>Note: 事实上 Spring 并没有能力识别一个组件到底是不是它所标记的类型。换言之，每一个注解在Spring看来是一个样，这些不同的注解，主要针对阅读程序的人来说。</p><h3 id="6-3-Spring注解扫描"><a href="#6-3-Spring注解扫描" class="headerlink" title="6.3 Spring注解扫描"></a>6.3 Spring注解扫描</h3><p>组件被上述注解标识后还需要通过 Spring 进行扫描才能够侦测到。</p><ol><li><p>指定被扫描的 package</p><pre><code class="hljs vhdl">&lt;<span class="hljs-keyword">context</span>:<span class="hljs-keyword">component</span>-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">"com.krismile.component"</span>/&gt;</code></pre></li><li><p>细节说明</p></li></ol><blockquote><p>[1]base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基 类包及其子包中的所有类。</p><p>[2]当需要扫描多个包时可以使用逗号分隔。</p><p>[3]包含与排除, <a href="context:include-filter">context:include-filter</a>子节点表示要包含的目标类,<br><a href="context:exclude-filter">context:exclude-filter</a>子节点表示要排除在外的目标类</p><p>[4]如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属 性过滤特定的类，示例：</p></blockquote><pre><code class="hljs xml">context:component-scan    base-package="com.krismile.component"    <span class="hljs-comment">&lt;!--  --&gt;</span>    resource-pattern="autowire/*.class"/&gt;</code></pre><p>Note: 如果是导入jar包的开发方式，需要额外导入 spring-aop-4.0.0.RELEASE.jar。</p><h3 id="6-4-组件装配"><a href="#6-4-组件装配" class="headerlink" title="6.4 组件装配"></a>6.4 组件装配</h3><blockquote><p>Controller 组件中往往需要用到 Service 组件的实例，Service 组件中往往需要用<br>到 Repository 组件的实例。Spring 可以通过注解的方式帮我们实现属性的装配。</p></blockquote><p>顺便一说： 在指定要扫描的包时，<a href="context:component-scan">context:component-scan</a> 元素会自动注册一个 bean的后置处理器：AutowiredAnnotationBeanPostProcessor的实例。该后置处理器可以自动装配标记了@Autowired、@Resource 或@Inject 注解的属性。</p><ol><li><p>@Autowired 注解</p><blockquote><p>根据类型实现自动装配 (先根据类型找， 再根据变量名即id找)<br>默认情况下，当 IOC 容器里存在多个类型兼容的 bean 时，Spring 会尝试匹<br>配 bean 的 id 值是否与变量名相同，如果相同则进行装配。如果 bean 的 id 值不相同，通过类型的自动装配将无法工作。</p></blockquote></li><li><p>@Resource 注解</p><blockquote><p>@Resource 注解要求提供一个 bean 名称的属性，若该属性为空，则自动采用 标注处的变量或方法名作为 bean 的名称。</p></blockquote></li><li><p>@Inject</p><blockquote><p>@Inject 和@Autowired 注解一样也是按类型注入匹配的 bean，但没有 reqired 属性。</p></blockquote></li></ol><hr><h2 id="7-整合多个配置文件"><a href="#7-整合多个配置文件" class="headerlink" title="7 整合多个配置文件"></a>7 整合多个配置文件</h2><ol><li><p>Spring 允许通过<import>将多个配置文件引入到一个文件中，进行配置文件的集成。 这样在启动 Spring容器时，仅需要指定这个合并好的配置文件就可以。</p></li><li><p>import 元素的 resource 属性支持 Spring 的标准的路径资源<br><img src="https://s1.ax1x.com/2020/08/12/ajEV0A.png" srcset="/img/loading.gif" alt="整合外部文件"></p></li></ol><h2 id="8-泛型依赖注入"><a href="#8-泛型依赖注入" class="headerlink" title="8 泛型依赖注入"></a>8 泛型依赖注入</h2><p>coding…</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础（一）概述</title>
    <link href="/2020/08/05/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/08/05/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><h2 id="1-Spring-概述"><a href="#1-Spring-概述" class="headerlink" title="1 Spring 概述"></a>1 Spring 概述</h2><p>①Spring 是一个开源框架</p><p>②Spring 为简化企业级开发而生，使用 Spring，JavaBean 就可以实现很多以前要靠 EJB<br>才能实现的功能。同样的功能，在 EJB 中要通过繁琐的配置和复杂的代码才能够实现，而在<br>Spring 中却非常的优雅和简洁。</p><p>③Spring 是一个 <strong><em>IOC(DI)</em></strong>和 <strong><em>AOP</em></strong> 容器框架。(<strong><em>控制反转</em></strong> &amp;&amp; <strong><em>面向切面编程</em></strong>)</p><p>④Spring 的优良特性</p><blockquote><p>[1] 非侵入式：基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API<br>[2] 依赖注入：DI——Dependency Injection，反转控制(IOC)最经典的实现。<br>[3] 面向切面编程：Aspect Oriented Programming——AOP<br>[4] 容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期<br>[5] 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。<br>[6] 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第<br>三方类库（实际上 Spring 自身也提供了表述层的 SpringMVC 和持久层的 Spring JDBC）。</p></blockquote><p>⑤Spring 目前的版本<br>缺图，待补</p><p>⑥Spring 模块<br>缺图，待补</p><h2 id="2-搭建-Spring-运行时环境"><a href="#2-搭建-Spring-运行时环境" class="headerlink" title="2 搭建 Spring 运行时环境"></a>2 搭建 Spring 运行时环境</h2><p>搭建Spring运行环境，有两种方式 — 大多数的环境搭建都如此。</p><h3 id="2-1-导入jar包方式"><a href="#2-1-导入jar包方式" class="headerlink" title="2.1 导入jar包方式"></a>2.1 导入jar包方式</h3><p>①加入 JAR 包</p><pre><code class="hljs css"><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-tag">Spring</span> 自身 <span class="hljs-selector-tag">JAR</span> 包：<span class="hljs-selector-tag">spring-framework-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span>\<span class="hljs-selector-tag">libs</span> 目录下<span class="hljs-selector-tag">spring-beans-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-context-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-core-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-expression-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-tag">commons-logging-1</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.jar</span></code></pre><blockquote><p>注意的是：你所需要导入的jar包需要根据实际需要来导入。换言之，你应该要了解Spring各个模块所需的jar包都是哪些。 Spring模块图见上文。</p></blockquote><p>②根据需要创建 Spring 配置文件</p><h3 id="2-2-Maven导入依赖"><a href="#2-2-Maven导入依赖" class="headerlink" title="2.2 Maven导入依赖"></a>2.2 Maven导入依赖</h3><p>Maven是一种项目管理工具，具体做的事就是：从’本地仓库’ 或 ‘远程仓库’中导入所需要的依赖坐标。这里所说的’依赖坐标’就是相关jar包的坐标，只需导入坐标的好处是可以降低程序臃肿程度，jar包就只用一份就可。</p><p>代码示例：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入spring-core依赖 --&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="3-Spring-HelloWorld"><a href="#3-Spring-HelloWorld" class="headerlink" title="3 Spring HelloWorld"></a>3 Spring HelloWorld</h2><p>一般的，学习一门编程语言，总是会以编写出HelloWorld代码来简单入门。<br>不失一般性，这里将以Spring HelloWorld方式来简单入门。</p><blockquote><p>①目标：使用 Spring 创建对象，为属性赋值<br>②创建 Student 类</p></blockquote><pre><code class="hljs angelscript"><span class="hljs-comment">// Student.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> &#123;    <span class="hljs-keyword">private</span> Integer studentId;    <span class="hljs-keyword">private</span> String stuName;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;    <span class="hljs-comment">// 省略getter/setter/toString</span>&#125;</code></pre><blockquote><p>③创建 Spring 配置文件</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring配置文件,这里命名为helloworld.xml --&gt;</span><span class="hljs-comment">&lt;!-- 名字命名无强制要求，这里为了突出意图，以此命名 --&gt;</span><span class="hljs-comment">&lt;!-- 使用bean元素定义一个由IOC容器创建的对象 --&gt;</span><span class="hljs-comment">&lt;!-- class属性指定用于创建bean的全类名 --&gt;</span><span class="hljs-comment">&lt;!-- id属性指定用于引用bean实例的标识 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"student"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.atguigu.helloworld.bean.Student"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 使用property子元素为bean的属性赋值 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"studentId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1001"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"stuName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Tom2015"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"20"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><blockquote><p>④测试：通过 Spring 的 IOC 容器创建 Student 类实例</p></blockquote><pre><code class="hljs arduino"><span class="hljs-comment">// junit测试类 - 测试方法</span>@Test<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//1.创建IOC容器对象</span>    ApplicationContext iocContainer = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"helloworld.xml"</span>);    <span class="hljs-comment">//2.根据id值获取bean实例对象</span>    Student student = (Student) iocContainer.getBean(<span class="hljs-string">"student"</span>);    <span class="hljs-comment">//3.打印bean</span>    System.out.<span class="hljs-built_in">println</span>(student);&#125;</code></pre><blockquote><p>⑤验证：Spring 在创建 IOC 容器对象时，就已经完成了 bean 的创建和属性的赋值。</p></blockquote><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><p>Spring框架相当于是一个容器，所有的类一旦被Spring容器管理起来，就不用我们去操心这些类的其一系列事情。<br>我们需要做的就是放心的将这些类交由Spring容器管理，然后舒舒服服的享受Spring带给我们的便利。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis框架总结（第一篇）</title>
    <link href="/2020/07/31/Mybatis%E6%80%BB%E7%BB%93(%E7%AC%AC%E4%B8%80%E7%AF%87)/"/>
    <url>/2020/07/31/Mybatis%E6%80%BB%E7%BB%93(%E7%AC%AC%E4%B8%80%E7%AF%87)/</url>
    
    <content type="html"><![CDATA[<h1 id="1-框架概述"><a href="#1-框架概述" class="headerlink" title="1 框架概述"></a>1 框架概述</h1><h2 id="1-1-什么是框架"><a href="#1-1-什么是框架" class="headerlink" title="1.1 什么是框架"></a>1.1 什么是框架</h2><h3 id="1-1-1-什么是框架"><a href="#1-1-1-什么是框架" class="headerlink" title="1.1.1 什么是框架"></a>1.1.1 什么是框架</h3><ul><li>框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。</li><li>简而言之，框架其实就是某种应用的半成品，就是一组组件。</li></ul><hr><h3 id="1-1-2-框架的作用"><a href="#1-1-2-框架的作用" class="headerlink" title="1.1.2 框架的作用"></a>1.1.2 框架的作用</h3><ul><li>框架要解决的最重要的一个问题是技术整合的问题。</li><li>软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应用的底层支撑，它不应该直接对应用产生影响。</li><li>框架一般处在低层应用平台（如J2EE）和高层业务逻辑之间的中间层。</li></ul><h3 id="1-1-3-Mybatis框架概述"><a href="#1-1-3-Mybatis框架概述" class="headerlink" title="1.1.3 Mybatis框架概述"></a>1.1.3 Mybatis框架概述</h3><ul><li><p>mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p></li><li><p>mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。</p></li><li><p>采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc-api打交道，就可以完成对数据库的持久化操作。</p></li></ul><hr><h2 id="1-2-JDBC编程回顾"><a href="#1-2-JDBC编程回顾" class="headerlink" title="1.2 JDBC编程回顾"></a>1.2 JDBC编程回顾</h2><h3 id="1-2-1-JDBC编程代码"><a href="#1-2-1-JDBC编程代码" class="headerlink" title="1.2.1 JDBC编程代码"></a>1.2.1 JDBC编程代码</h3><pre><code class="hljs d"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;Connection connection = <span class="hljs-literal">null</span>;PreparedStatement preparedStatement = <span class="hljs-literal">null</span>;ResultSet resultSet = <span class="hljs-literal">null</span>;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//加载数据库驱动</span>Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);<span class="hljs-comment">//通过驱动管理类获取数据库链接</span>connection = DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8"</span>,<span class="hljs-string">"ro</span><span class="hljs-string">ot"</span>, <span class="hljs-string">"root"</span>);<span class="hljs-comment">//定义 sql 语句 ?表示占位符</span>String sql = <span class="hljs-string">"select * from user where username = ?"</span>;<span class="hljs-comment">//获取预处理 statement</span>preparedStatement = connection.prepareStatement(sql);<span class="hljs-comment">//设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为设置的</span>参数值preparedStatement.setString(<span class="hljs-number">1</span>, <span class="hljs-string">"王五"</span>);<span class="hljs-comment">//向数据库发出 sql 执行查询，查询出结果集</span>resultSet = preparedStatement.executeQuery();<span class="hljs-comment">//遍历查询结果集</span><span class="hljs-keyword">while</span>(resultSet.next())&#123; System.<span class="hljs-keyword">out</span>.println(resultSet.getString(<span class="hljs-string">"id"</span>)+<span class="hljs-string">"</span><span class="hljs-string"> "</span>+resultSet.getString(<span class="hljs-string">"username"</span>));&#125;&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">finally</span>&#123;<span class="hljs-comment">//释放资源</span><span class="hljs-keyword">if</span>(resultSet!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-keyword">try</span> &#123;resultSet.close();&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;e.printStackTrace();&#125; &#125;<span class="hljs-keyword">if</span>(preparedStatement!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-keyword">try</span> &#123;preparedStatement.close();&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;e.printStackTrace();&#125; &#125;<span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-keyword">try</span> &#123;connection.close();&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;e.printStackTrace();&#125; &#125; &#125; &#125;</code></pre><h3 id="1-2-2-JDBC问题分析"><a href="#1-2-2-JDBC问题分析" class="headerlink" title="1.2.2 JDBC问题分析"></a>1.2.2 JDBC问题分析</h3><ul><li>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</li><li>2、Sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</li><li>3、使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</li><li>4、对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。</li></ul><hr><h1 id="2-Mybatis框架快速入门"><a href="#2-Mybatis框架快速入门" class="headerlink" title="2 Mybatis框架快速入门"></a>2 Mybatis框架快速入门</h1><h2 id="2-1-开发准备"><a href="#2-1-开发准备" class="headerlink" title="2.1 开发准备"></a>2.1 开发准备</h2><ul><li>方式一：</li></ul><blockquote><p>网上下载Mybatis相关jar包，将mybatis-x.x.x.jar文件加入到项目中，即可。</p></blockquote><ul><li>方式二：</li></ul><blockquote><p>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：</p></blockquote><pre><code class="hljs dts"><span class="hljs-comment">// pom.xml中添加依赖</span><span class="hljs-params">&lt;dependency&gt;</span>  <span class="hljs-params">&lt;groupId&gt;</span>org.mybatis<span class="hljs-params">&lt;/groupId&gt;</span>  <span class="hljs-params">&lt;artifactId&gt;</span>mybatis<span class="hljs-params">&lt;/artifactId&gt;</span>  <span class="hljs-params">&lt;version&gt;</span>x.x.x<span class="hljs-params">&lt;/version&gt;</span><span class="hljs-params">&lt;/dependency&gt;</span></code></pre><hr><h2 id="2-2-Mybatis的主配置文件-SqlMapConfig-xml"><a href="#2-2-Mybatis的主配置文件-SqlMapConfig-xml" class="headerlink" title="2.2 Mybatis的主配置文件(SqlMapConfig.xml)"></a>2.2 Mybatis的主配置文件(SqlMapConfig.xml)</h2><p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span></span><span class="xml">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span><span class="xml">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;driver&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;url&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;username&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;password&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></span><span class="xml">  // 每一个mapper对应着一些sql操作的集合</span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span></code></pre><p>当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。</p><hr><h2 id="2-3-写在前面"><a href="#2-3-写在前面" class="headerlink" title="2.3 写在前面"></a>2.3 写在前面</h2><ul><li>Mybatis操作以<strong><em>SQLSession</em></strong>为基本单位，SQLSession基于SQLSessionFactory</li><li><strong><em>SqlSessionFactory</em></strong> 是核心的。</li><li>SqlSessionFactory 的实例可以通过 <strong><em>SqlSessionFactoryBuilder</em></strong> 获得</li><li>SqlSessionFactoryBuilder 则可以通过：<strong><em>XML 配置文件</em></strong> 或者 预先配置的 <strong><em>Configuration</em></strong> 实例来获取</li></ul><hr><h2 id="2-4-基于xml配置的Mybatis具体案例"><a href="#2-4-基于xml配置的Mybatis具体案例" class="headerlink" title="2.4 基于xml配置的Mybatis具体案例"></a>2.4 基于xml配置的Mybatis具体案例</h2><h3 id="2-4-0-Maven项目搭建"><a href="#2-4-0-Maven项目搭建" class="headerlink" title="2.4.0 Maven项目搭建"></a>2.4.0 Maven项目搭建</h3><blockquote><p>在pom.xml文件中添加Mybatis的坐标，如下：</p></blockquote><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.x.x<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><hr><h3 id="2-4-1-编写User实体类"><a href="#2-4-1-编写User实体类" class="headerlink" title="2.4.1 编写User实体类"></a>2.4.1 编写User实体类</h3><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Serializable</span></span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> username;    <span class="hljs-keyword">private</span> Date birthday;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> sex;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> address;        <span class="hljs-comment">// getter/setter/toString略</span>&#125;</code></pre><hr><h3 id="2-4-2-编写持久层接口-IUserDao"><a href="#2-4-2-编写持久层接口-IUserDao" class="headerlink" title="2.4.2 编写持久层接口 IUserDao"></a>2.4.2 编写持久层接口 IUserDao</h3><pre><code class="hljs php">IUserDao 接口就是我们的持久层接口（也可以写成 UserDao 或者 UserMapper）,具体代码如下：<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    * 查询所有用户</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">List</span>&lt;User&gt; findAll();&#125;</code></pre><hr><h3 id="2-4-3-编写持久层接口的映射文件-IUserDao-xml"><a href="#2-4-3-编写持久层接口的映射文件-IUserDao-xml" class="headerlink" title="2.4.3 编写持久层接口的映射文件 IUserDao.xml"></a>2.4.3 编写持久层接口的映射文件 IUserDao.xml</h3><p>要求：</p><ol><li>创建位置：必须和持久层接口在相同的包中</li><li>名称：必须以持久层接口名称命名文件名，扩展名是.xml</li></ol><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> </span><span class="hljs-meta"> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> </span><span class="hljs-meta"> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span>  //命名空间 <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.itheima.dao.IUserDao"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置查询所有操作 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.itheima.domain.User"</span>&gt;</span>        select * from user    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><hr><h3 id="2-4-4-编写-SqlMapConfig-xml-配置文件"><a href="#2-4-4-编写-SqlMapConfig-xml-配置文件" class="headerlink" title="2.4.4 编写 SqlMapConfig.xml 配置文件"></a>2.4.4 编写 SqlMapConfig.xml 配置文件</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span> </span><span class="hljs-meta"> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> </span><span class="hljs-meta"> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置 mybatis 的环境 --&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"mysql"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 配置 mysql 的环境 --&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mysql"</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 配置事务的类型 --&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>                 <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/ee50"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1234"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 告知 mybatis 映射配置的位置 --&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/itheima/dao/IUserDao.xml"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><hr><h3 id="2-4-5-编写Mybatis测试类"><a href="#2-4-5-编写Mybatis测试类" class="headerlink" title="2.4.5 编写Mybatis测试类"></a>2.4.5 编写Mybatis测试类</h3><pre><code class="hljs reasonml"><span class="hljs-comment">// 标准的操作应该我们手动处理掉异常</span><span class="hljs-comment">// 应该使用 try-catch-finally方式</span><span class="hljs-comment">// 这里为了篇幅，就直接抛出异常了...</span>public <span class="hljs-keyword">class</span> MybatisTest &#123;    public static void main(String<span class="hljs-literal">[]</span> args) throws Exception &#123;        <span class="hljs-comment">//1.读取配置文件</span>        InputStream <span class="hljs-keyword">in</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Resources</span>.</span></span>get<span class="hljs-constructor">ResourceAsStream(<span class="hljs-string">"SqlMapConfig.xml"</span>)</span>;        <span class="hljs-comment">//2.创建 SqlSessionFactory 的构建者对象</span>        SqlSessionFactoryBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SqlSessionFactoryBuilder()</span>;        <span class="hljs-comment">//3.使用构建者创建工厂对象 SqlSessionFactory</span>        SqlSessionFactory factory = builder.build(<span class="hljs-keyword">in</span>);        <span class="hljs-comment">//4.使用 SqlSessionFactory 生产 SqlSession 对象</span>        SqlSession session = factory.<span class="hljs-keyword">open</span><span class="hljs-constructor">Session()</span>;        <span class="hljs-comment">//5.使用 SqlSession 创建 dao 接口的代理对象</span>        IUserDao userDao = session.get<span class="hljs-constructor">Mapper(IUserDao.<span class="hljs-params">class</span>)</span>;        <span class="hljs-comment">//6.使用代理对象执行查询所有方法</span>        List&lt;User&gt; users = userDao.find<span class="hljs-constructor">All()</span>;        for(User user : users) &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(user);        &#125;        <span class="hljs-comment">//7.释放资源</span>        session.close<span class="hljs-literal">()</span>;        <span class="hljs-keyword">in</span>.close<span class="hljs-literal">()</span>;    &#125;&#125;</code></pre><hr><h2 id="2-5-入门小结"><a href="#2-5-入门小结" class="headerlink" title="2.5 入门小结"></a>2.5 入门小结</h2><ol><li>使用Mybatis框架操作数据库，让我们的工作显得相对简单很多。因为只需要编写 Dao 接口并且按照mybatis<br>要求编写两个配置文件，就可以实现功能。远比我们之前的 jdbc 方便多了。</li><li>我们使用注解之后，将变得更为简单，只需要编写一个 mybatis 配置文件就够了。</li><li>这里面的一些具体的类、接口、操作的意义暂时可以先不管，后续我们再慢慢展开…</li></ol><hr><h1 id="3-Mybatis注解开发（介绍）"><a href="#3-Mybatis注解开发（介绍）" class="headerlink" title="3. Mybatis注解开发（介绍）"></a>3. Mybatis注解开发（介绍）</h1><h2 id="3-0-写在前面"><a href="#3-0-写在前面" class="headerlink" title="3.0 写在前面"></a>3.0 写在前面</h2><ul><li><p>Mybatis提供了一系列注解，可以实现对xml中的某些配置的精简化，从而使开发更加简便。</p></li><li><p>虽然注解开发十分简便，几乎可以做到0配置（xml），码代码速度快。值得一提的是，这种纯注解的方式，并不十分推荐。原因之一便是造成代码的可读性变差，可维护性变差。</p></li><li><p>开发中推荐使用”半”注解,”半”xml的方式。</p></li></ul><h2 id="3-1-注解开发"><a href="#3-1-注解开发" class="headerlink" title="3.1 注解开发"></a>3.1 注解开发</h2><h3 id="3-1-1-在持久层接口中添加注解"><a href="#3-1-1-在持久层接口中添加注解" class="headerlink" title="3.1.1 在持久层接口中添加注解"></a>3.1.1 在持久层接口中添加注解</h3><pre><code class="hljs dart">public <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;    <span class="hljs-comment"><span class="markdown">/**</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">    * </span>查询所有用户</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet">    * </span>@return</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-code">    */</span></span></span>    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from user"</span>) <span class="hljs-comment">// 添加注解</span>    <span class="hljs-built_in">List</span>&lt;User&gt; findAll();&#125;</code></pre><h3 id="3-1-2-SqlMapConfig-xml配置"><a href="#3-1-2-SqlMapConfig-xml配置" class="headerlink" title="3.1.2 SqlMapConfig.xml配置"></a>3.1.2 SqlMapConfig.xml配置</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 告知 mybatis 映射配置的位置 --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.dao.IUserDao"</span>/&gt;</span>    // 在使用基于注解的 Mybatis 配置时，请移除 xml 的映射配置（IUserDao.xml）。    /**     在前文中，我们使用IUserDao.xml文件来配置，此时我们有了Select注解，就不再需要了，只需告知Mybatis，注解dao接口的位置即可。    */<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre><h3 id="3-1-3-注解简要介绍"><a href="#3-1-3-注解简要介绍" class="headerlink" title="3.1.3 注解简要介绍"></a>3.1.3 注解简要介绍</h3><blockquote><p>值得一提的是，这里将介绍几种基本的注解。具体操作，之后慢慢展开，这里我们只要知道一点， Mybatis的强大，让我们开发效率变得简单。</p></blockquote><pre><code class="hljs less"><span class="hljs-variable">@Insert:</span>实现新增<span class="hljs-variable">@Update</span>:实现更新<span class="hljs-variable">@Delete</span>:实现删除<span class="hljs-variable">@Select</span>:实现查询<span class="hljs-variable">@Result</span>:实现结果集封装<span class="hljs-variable">@Results</span>:可以与<span class="hljs-variable">@Result</span> 一起使用，封装多个结果集<span class="hljs-variable">@ResultMap</span>:实现引用<span class="hljs-variable">@Results</span> 定义的封装<span class="hljs-variable">@One</span>:实现一对一结果集封装<span class="hljs-variable">@Many</span>:实现一对多结果集封装<span class="hljs-variable">@SelectProvider</span>: 实现动态 SQL 映射<span class="hljs-variable">@CacheNamespace</span>:实现注解二级缓存的使用</code></pre><h1 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h1>]]></content>
    
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Test001</title>
    <link href="/2020/07/28/My-Test001/"/>
    <url>/2020/07/28/My-Test001/</url>
    
    <content type="html"><![CDATA[<h2 id="第一个标题"><a href="#第一个标题" class="headerlink" title="第一个标题"></a>第一个标题</h2><h3 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h3><p><img src="/img/yql.jpg" srcset="/img/loading.gif" alt="岳绮罗"></p><hr><h2 id="第二个标题"><a href="#第二个标题" class="headerlink" title="第二个标题"></a>第二个标题</h2><p><img src="/img/avatar001.png" srcset="/img/loading.gif" alt="犇"></p><hr><h2 id="写到这儿"><a href="#写到这儿" class="headerlink" title="写到这儿"></a>写到这儿</h2><hr>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo如何添加分类和标签</title>
    <link href="/2020/07/28/Hexo%E5%8D%9A%E5%AE%A2-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/"/>
    <url>/2020/07/28/Hexo%E5%8D%9A%E5%AE%A2-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-文章分类"><a href="#1-文章分类" class="headerlink" title="1. 文章分类"></a>1. 文章分类</h1><h2 id="1-1-生成分类目录"><a href="#1-1-生成分类目录" class="headerlink" title="1.1 生成分类目录"></a>1.1 生成分类目录</h2><pre><code class="hljs routeros">hexo new<span class="hljs-built_in"> page </span>categories</code></pre><p>生成目录之后，会在根目录的source目录中多出一个categories目录。</p><h2 id="1-2-分类配置"><a href="#1-2-分类配置" class="headerlink" title="1.2 分类配置"></a>1.2 分类配置</h2><p>在categories目录中有一个index.md文件，在文件中添加type: categories</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">分类</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">categories</span><span class="hljs-meta">---</span></code></pre><h2 id="1-3-增加多个分类"><a href="#1-3-增加多个分类" class="headerlink" title="1.3 增加多个分类"></a>1.3 增加多个分类</h2><p>在categories目录中有一个index.md文件，复制多份就可以了</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">分类一</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">categories</span><span class="hljs-meta">---</span><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">分类二</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">categories</span><span class="hljs-meta">---</span></code></pre><h2 id="1-4-给文章添加”分类”属性"><a href="#1-4-给文章添加”分类”属性" class="headerlink" title="1.4 给文章添加”分类”属性"></a>1.4 给文章添加”分类”属性</h2><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">categories:</span> <span class="hljs-string">分类</span><span class="hljs-meta">---</span></code></pre><p>文章分类属性只能存在一个，如果写了多个，只有第一个会启效果</p><h1 id="2-文章标签"><a href="#2-文章标签" class="headerlink" title="2. 文章标签"></a>2. 文章标签</h1><h2 id="2-1-生成标签目录"><a href="#2-1-生成标签目录" class="headerlink" title="2.1 生成标签目录"></a>2.1 生成标签目录</h2><pre><code class="hljs routeros">hexo new<span class="hljs-built_in"> page </span>tags</code></pre><p>生成目录之后，会在根目录的source目录中多出一个tags目录。</p><h2 id="2-2-标签配置"><a href="#2-2-标签配置" class="headerlink" title="2.2 标签配置"></a>2.2 标签配置</h2><p>在tags目录中有一个index.md文件，在文件中添加type: tags</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">标签</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">tags</span><span class="hljs-meta">---</span></code></pre><h2 id="2-3-增加多个标签"><a href="#2-3-增加多个标签" class="headerlink" title="2.3 增加多个标签"></a>2.3 增加多个标签</h2><p>在tags目录中有一个index.md文件，复制多份就可以了</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">标签一</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">tags</span><span class="hljs-meta">---</span><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">标签二</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">tags</span><span class="hljs-meta">---</span></code></pre><h2 id="2-4-给文章添加”标签”属性"><a href="#2-4-给文章添加”标签”属性" class="headerlink" title="2.4 给文章添加”标签”属性"></a>2.4 给文章添加”标签”属性</h2><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">categories:</span> <span class="hljs-string">分类</span><span class="hljs-attr">tags:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签一</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签二</span><span class="hljs-meta">---</span></code></pre><p>文章标签属性可存在多个</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
