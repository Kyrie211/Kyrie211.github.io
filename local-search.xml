<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mybatis 总结</title>
    <link href="/2020/08/31/Mybatis-%E6%80%BB%E7%BB%93/"/>
    <url>/2020/08/31/Mybatis-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis总结"><a href="#Mybatis总结" class="headerlink" title="Mybatis总结"></a>Mybatis总结</h1><p>转载自：<a href="https://www.jimu98.cn/2020/08/08/java/%E3%80%90Java%E6%80%BB%E7%BB%93%E3%80%91Mybatis/" target="_blank" rel="noopener">积木98</a></p><h2 id="什么是MyBatis？"><a href="#什么是MyBatis？" class="headerlink" title="什么是MyBatis？"></a>什么是MyBatis？</h2><p>MyBatis 本是 apache 的一个开源项目 iBatis，Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p><h2 id="Mybaits的优点？"><a href="#Mybaits的优点？" class="headerlink" title="Mybaits的优点？"></a>Mybaits的优点？</h2><p>（1）基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</p><p>（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</p><p>（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</p><p>（4）能够与Spring很好的集成；</p><p>（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p><ul><li>缺点：</li></ul><p>（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</p><p>（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h2 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h2><p>mybatis提供查询缓存，用于减轻数据库压力，提高数据库性能</p><p>MyBatis的缓存分为一级缓存和二级缓存，分别如下：</p><ul><li>一级缓存放在session里面，默认就有。</li><li>二级缓存放在它的命名空间里，默认是打开的。使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<br>在config.xml设置二级缓存开关 ， 还要在具体的mapper.xml开启二级缓存<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-comment">&lt;!--开启二级缓存--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre>需要将映射的javapojo类实现序列化<pre><code class="hljs routeros">&lt;cache <span class="hljs-attribute">eviction</span>=<span class="hljs-string">"LRU"</span> <span class="hljs-attribute">flushInterval</span>=<span class="hljs-string">"10000"</span>/&gt;</code></pre><h2 id="MyBatis使用"><a href="#MyBatis使用" class="headerlink" title="MyBatis使用"></a>MyBatis使用</h2>创建流程<h3 id="1-创建mybatis-config-xml"><a href="#1-创建mybatis-config-xml" class="headerlink" title="1.创建mybatis-config.xml"></a>1.创建mybatis-config.xml</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><span class="hljs-comment">&lt;!--configuration核心配置--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-comment">&lt;!--environments可以配置多个环境，default选择默认环境--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>            <span class="hljs-comment">&lt;!--事务管理--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/mybatis？useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"guo"</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"guo"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre><h3 id="2-编辑mybatis工具类"><a href="#2-编辑mybatis工具类" class="headerlink" title="2.编辑mybatis工具类"></a>2.编辑mybatis工具类</h3><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUtils</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//第一步！</span>            <span class="hljs-comment">// /*使用mybatis获取sqlSessionFactory对象*/</span>            <span class="hljs-keyword">String</span> resource = <span class="hljs-string">"mybatis-config.xml"</span>;            <span class="hljs-comment">/*获取配置文件resource*/</span>            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**第二步！！</span><span class="hljs-comment">     * 从sqlSessionFactory中获取sqlsession</span><span class="hljs-comment">     * sqlsession完全包含了面向数据库执行sql命令所需的所有方法</span><span class="hljs-comment">     * */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();    &#125;&#125;</code></pre><h3 id="3-创建mapper映射文件"><a href="#3-创建mapper映射文件" class="headerlink" title="3.创建mapper映射文件"></a>3.创建mapper映射文件</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><span class="hljs-comment">&lt;!--接口实现类由原来的userdaoimpl转变为一个mapper配置文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"cn.jimu98.dao.UserDao"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserList"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"cn.jimu98.pojo.User"</span>&gt;</span>        select * from user    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> UserDaoTest &#123;    @Test    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> test()&#123;        SqlSession sqlSession = MybatisUtils.getSqlSession();        UserDao userDao = sqlSession.getMapper(UserDao.<span class="hljs-keyword">class</span>);        List&lt;<span class="hljs-keyword">User</span>&gt; userList = userDao.getUserList();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> : userList) &#123;            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>);        &#125;        sqlSession.<span class="hljs-keyword">close</span>();    &#125;&#125;</code></pre><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><h3 id="引入外部配置文件"><a href="#引入外部配置文件" class="headerlink" title="引入外部配置文件"></a>引入外部配置文件</h3>db.properties<pre><code class="hljs ini"><span class="hljs-attr">db.username</span>=root<span class="hljs-attr">db.password</span>=<span class="hljs-number">123</span><span class="hljs-attr">db.driver</span>=com.mysql.cj.jdbc.Driver<span class="hljs-attr">db.url</span>=jdbc:mysql:///test01?serverTimezone=Asia/Shanghai</code></pre>mybatis-config.xml<pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"db.properties"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;db.driver&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;db.url&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;db.username&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;db.password&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.jimu98.mybatis.mapper"</span>/&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span></code></pre></li></ul><h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><p>…</p><h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><blockquote><p>这个是 MyBatis 中定义的别名，分两种，一种是 MyBatis 自带的别名，另一种是我们自定义的别名。</p></blockquote><p>本来，我们在 Mapper 中定义数据类型时，需要写全路径，如下：</p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> id="getUserCount" resultType="java.lang.Integer"&gt;    <span class="hljs-keyword">select</span> count(*) <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> ;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><p>但是，每次写全路径比较麻烦。这种时候，我们可以用类型的别名来代替，例如用 int 做 Integer 的别名：</p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> id="getUserCount" resultType="int"&gt;    <span class="hljs-keyword">select</span> count(*) <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> ;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><h3 id="自定义别名"><a href="#自定义别名" class="headerlink" title="自定义别名"></a>自定义别名</h3><p>我们自己的对象，在 Mapper 中定义的时候，也是需要写全路径：</p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> id="getAllUser" resultType="cn.jimu98.mybatis.model.User"&gt;    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><p>这种情况下，写全路径也比较麻烦，我们可以给我们自己的 User 对象取一个别名，在 mybatis-config.xml 中添加 typeAliases 节点：</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"db.properties"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"cn.jimu98.mybatis.model.User"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"java"</span>/&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;db.driver&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;db.url&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;db.username&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;db.password&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span></span><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.jimu98.mybatis.mapper"</span>/&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span></code></pre><p>这里，我们给 User 对象取了一个别名叫 jimu98，然后，我们就可以在 Mapper 中直接使用 jimu98来代替 User 对象了：</p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> id="getAllUser" resultType="jimu98"&gt;    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><p>但是，这种一个一个去枚举对象的过程非常麻烦，我们还可以批量给对象定义别名，批量定义主要是利用包扫描来做，批量定义默认的类的别名，是类名首字母小写，例如如下配置：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cn.jimu98.mybatis.model"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre><p>这个配置就表示给 cn.jimu98.mybatis.model 包下的所有类取别名，默认的别名就是类名首字母小写。这个时候，我们在 Mapper 中，就可以利用 user 代替 User 全路径了：</p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> id="getAllUser" resultType="user"&gt;    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><p>在最新版中，批量定义的别名，类名首字母也可以不用小写，在实际开发中，我们一般使用第二种方式（批量定义的方式）</p><h2 id="Mapper-映射文件"><a href="#Mapper-映射文件" class="headerlink" title="Mapper 映射文件"></a>Mapper 映射文件</h2><h3 id="parameterType"><a href="#parameterType" class="headerlink" title="parameterType"></a>parameterType</h3><blockquote><p>这个表示输入的参数类型。</p></blockquote><p>在 MyBatis 中，我们在 mapper 引用变量时，默认使用的是 #，像下面这样：</p><select id="getUserById" resultType="cn.jimu98.mybatis.model.User">    select * from user where id=#{id};</select>除了使用 # 之外，我们也可以使用 $ 来引用一个变量：<pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> id="getUserById" resultType="cn.jimu98.mybatis.model.User"&gt;    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id=$&#123;id&#125;;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre>$ 相当于是参数拼接的方式，而 # 则相当于是占位符的方式。<h3 id="对象参数"><a href="#对象参数" class="headerlink" title="对象参数"></a>对象参数</h3><p>例如添加一个用户：</p><pre><code class="hljs crmsh">Integer addUser(<span class="hljs-keyword">User</span> <span class="hljs-title">user</span>);</code></pre><p>对应的 mapper 文件如下：</p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id="addUser" parameterType="cn.jimu98.mybatis.model.User"&gt;    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> (username,address,favorites) <span class="hljs-keyword">values</span> (#&#123;username&#125;,#&#123;address&#125;,#&#123;favorites,typeHandler=cn.jimu98.mybatis.typehandler.List2VarcharHandler&#125;);&lt;/<span class="hljs-keyword">insert</span>&gt;</code></pre><p>我们在引用的时候，直接使用属性名就能够定位到对象了。如果对象存在多个，我们也需要给对象添加 @Param 注解，如果给对象添加了 @Param 注解，那么对象属性的引用，会有一些变化。如下：</p><pre><code class="hljs less"><span class="hljs-selector-tag">Integer</span> <span class="hljs-selector-tag">addUser</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">"user"</span>) User user);</code></pre><p>如果对象参数添加了 @Param 注解，Mapper 中的写法就会发生变化：</p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">insert</span> id="addUser" parameterType="cn.jimu98.mybatis.model.User"&gt;    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> (username,address,favorites) <span class="hljs-keyword">values</span> (#&#123;<span class="hljs-keyword">user</span>.username&#125;,#&#123;<span class="hljs-keyword">user</span>.address&#125;,#&#123;<span class="hljs-keyword">user</span>.favorites,typeHandler=cn.jimu98.mybatis.typehandler.List2VarcharHandler&#125;);&lt;/<span class="hljs-keyword">insert</span>&gt;</code></pre><p>注意多了一个前缀，这个前缀不是变量名，而是 @Param 注解中定义名称。</p><h3 id="Map-参数"><a href="#Map-参数" class="headerlink" title="Map 参数"></a>Map 参数</h3><p>如果想要使用 Map 传递参数，技术上来说，肯定是没有问题的。</p><pre><code class="hljs processing">Integer updateUsernameById(<span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>,<span class="hljs-keyword">Object</span>&gt; <span class="hljs-built_in">map</span>);</code></pre><p>XML 文件写法如下：</p><pre><code class="hljs n1ql">&lt;<span class="hljs-keyword">update</span> id=<span class="hljs-string">"updateUsernameById"</span>&gt;    <span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> username = #&#123;username&#125; <span class="hljs-keyword">where</span> id=#&#123;id&#125;;&lt;/<span class="hljs-keyword">update</span>&gt;</code></pre><p>引用的变量名，就是 map 中的 key。基本上和实体类是一样的，如果给 map 取了别名，那么在引用的时候，也要将别名作为前缀加上，这一点和实体类也是一样的。</p><h3 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h3><p>resultType 是返回类型，在实际开发中，如果返回的数据类型比较复杂，一般我们使用 resultMap，但是，对于一些简单的返回，使用 resultType 就够用了。</p><p>resultType 返回的类型可以是简单类型，可以是对象，可以是集合，也可以是一个 hashmap，如果是 hashmap，map 中的 key 就是字段名，value 就是字段的值。</p><h3 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h3><p>先来看一个基本用法：</p><p>首先在 mapper.xml 中定义一个 resultMap：</p><pre><code class="hljs applescript">&lt;resultMap <span class="hljs-built_in">id</span>=<span class="hljs-string">"MyResultMap"</span> type=<span class="hljs-string">"org.javaboy.mybatis.model.User"</span>&gt;    &lt;<span class="hljs-built_in">id</span> column=<span class="hljs-string">"id"</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">"id"</span>/&gt;    &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">"username"</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">"username"</span>/&gt;    &lt;<span class="hljs-literal">result</span> column=<span class="hljs-string">"address"</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">"address"</span>/&gt;&lt;/resultMap&gt;</code></pre><p>在这个 resultMap 中，id 用来描述主键，column 是数据库查询出来的列名，property 则是对象中的属性名。</p><p>然后在查询结果中，定义返回值时使用这个 ResultMap：</p><pre><code class="hljs cs">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">"getUserById"</span> resultMap=<span class="hljs-string">"MyResultMap"</span>&gt;    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> user <span class="hljs-keyword">where</span> id=<span class="hljs-meta">#&#123;id&#125;;</span>&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><h2 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h2><p>动态 SQL 是 MyBatis 中非常强大的一个功能。例如一些常见的查询场景：</p><ul><li>查询条件不确定</li><li>批量插入</li></ul><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：</p><pre><code class="hljs vbnet">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">"findActiveBlogWithTitleLike"</span>     resultType=<span class="hljs-string">"Blog"</span>&gt;  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> BLOG  <span class="hljs-keyword">WHERE</span> state = ‘ACTIVE’  &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">"title != null"</span>&gt;    <span class="hljs-keyword">AND</span> title <span class="hljs-keyword">like</span> <span class="hljs-meta">#&#123;title&#125;</span>  &lt;/<span class="hljs-keyword">if</span>&gt;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。</p><p>如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。</p><pre><code class="hljs vbnet">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">"findActiveBlogLike"</span>     resultType=<span class="hljs-string">"Blog"</span>&gt;  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> BLOG <span class="hljs-keyword">WHERE</span> state = ‘ACTIVE’  &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">"title != null"</span>&gt;    <span class="hljs-keyword">AND</span> title <span class="hljs-keyword">like</span> <span class="hljs-meta">#&#123;title&#125;</span>  &lt;/<span class="hljs-keyword">if</span>&gt;  &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">"author != null and author.name != null"</span>&gt;    <span class="hljs-keyword">AND</span> author_name <span class="hljs-keyword">like</span> <span class="hljs-meta">#&#123;author.name&#125;</span>  &lt;/<span class="hljs-keyword">if</span>&gt;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><h4 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h4><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）。</p><pre><code class="hljs vbnet">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">"findActiveBlogLike"</span>     resultType=<span class="hljs-string">"Blog"</span>&gt;  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> BLOG <span class="hljs-keyword">WHERE</span> state = ‘ACTIVE’  &lt;choose&gt;    &lt;<span class="hljs-keyword">when</span> test=<span class="hljs-string">"title != null"</span>&gt;      <span class="hljs-keyword">AND</span> title <span class="hljs-keyword">like</span> <span class="hljs-meta">#&#123;title&#125;</span>    &lt;/<span class="hljs-keyword">when</span>&gt;    &lt;<span class="hljs-keyword">when</span> test=<span class="hljs-string">"author != null and author.name != null"</span>&gt;      <span class="hljs-keyword">AND</span> author_name <span class="hljs-keyword">like</span> <span class="hljs-meta">#&#123;author.name&#125;</span>    &lt;/<span class="hljs-keyword">when</span>&gt;    &lt;otherwise&gt;      <span class="hljs-keyword">AND</span> featured = <span class="hljs-number">1</span>    &lt;/otherwise&gt;  &lt;/choose&gt;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><h4 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h4><p>前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state = ‘ACTIVE’” 设置成动态条件，看看会发生什么。</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findActiveBlogLike"</span></span></span><span class="xml">     resultType="Blog"&gt;</span><span class="xml">  SELECT * FROM BLOG</span><span class="xml">  WHERE</span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"state != null"</span>&gt;</span></span><span class="xml">    state = #</span><span class="hljs-template-variable">&#123;state&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"title != null"</span>&gt;</span></span><span class="xml">    AND title like #</span><span class="hljs-template-variable">&#123;title&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"author != null and author.name != null"</span>&gt;</span></span><span class="xml">    AND author_name like #</span><span class="hljs-template-variable">&#123;author.name&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre><p>如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> BLOG<span class="hljs-keyword">WHERE</span></code></pre><p>这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> BLOG<span class="hljs-keyword">WHERE</span><span class="hljs-keyword">AND</span> <span class="hljs-built_in">title</span> <span class="hljs-keyword">like</span> ‘someTitle’</code></pre><p>这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。</p><p>MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findActiveBlogLike"</span></span></span><span class="xml">     resultType="Blog"&gt;</span><span class="xml">  SELECT * FROM BLOG</span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"state != null"</span>&gt;</span></span><span class="xml">         state = #</span><span class="hljs-template-variable">&#123;state&#125;</span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"title != null"</span>&gt;</span></span><span class="xml">        AND title like #</span><span class="hljs-template-variable">&#123;title&#125;</span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"author != null and author.name != null"</span>&gt;</span></span><span class="xml">        AND author_name like #</span><span class="hljs-template-variable">&#123;author.name&#125;</span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span></code></pre><p>where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。</p><p>如果 where 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"WHERE"</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">"AND |OR "</span>&gt;</span>  ...<span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></code></pre><p>prefixOverrides 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容。</p><p>用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"updateAuthorIfNecessary"</span>&gt;</span></span><span class="xml">  update Author</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username != null"</span>&gt;</span>username=#</span><span class="hljs-template-variable">&#123;username&#125;</span><span class="xml">,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"password != null"</span>&gt;</span>password=#</span><span class="hljs-template-variable">&#123;password&#125;</span><span class="xml">,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"email != null"</span>&gt;</span>email=#</span><span class="hljs-template-variable">&#123;email&#125;</span><span class="xml">,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"bio != null"</span>&gt;</span>bio=#</span><span class="hljs-template-variable">&#123;bio&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span></span><span class="xml">  where id=#</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span></code></pre><p>这个例子中，set 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p><p>来看看与 set 元素等价的自定义 trim 元素吧：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">"SET"</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">","</span>&gt;</span>  ...<span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span></code></pre><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值。</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> id="selectPostIn" resultType="domain.blog.Post"&gt;  <span class="hljs-keyword">SELECT</span> *  <span class="hljs-keyword">FROM</span> POST P  <span class="hljs-keyword">WHERE</span> ID <span class="hljs-keyword">in</span>  &lt;<span class="hljs-keyword">foreach</span> item="item" <span class="hljs-keyword">index</span>="index" collection="list"      <span class="hljs-keyword">open</span>="(" separator="," <span class="hljs-keyword">close</span>=")"&gt;        #&#123;item&#125;  &lt;/<span class="hljs-keyword">foreach</span>&gt;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><p>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p><p>提示 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p><p>至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。</p><h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><p>要在带注解的映射器接口类中使用动态 SQL，可以使用 script 元素。比如:</p><pre><code class="hljs xml">@Update(&#123;"<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>",<span class="actionscript">  <span class="hljs-string">"update Author"</span>,</span><span class="actionscript">  <span class="hljs-string">"  &lt;set&gt;"</span>,</span><span class="handlebars"><span class="xml">  "    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">'username != null'</span>&gt;</span>username=#&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>",</span></span><span class="handlebars"><span class="xml">  "    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">'password != null'</span>&gt;</span>password=#&#123;password&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>",</span></span><span class="handlebars"><span class="xml">  "    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">'email != null'</span>&gt;</span>email=#&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>",</span></span><span class="handlebars"><span class="xml">  "    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">'bio != null'</span>&gt;</span>bio=#&#123;bio&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>",</span></span><span class="actionscript">  <span class="hljs-string">"  &lt;/set&gt;"</span>,</span><span class="actionscript">  <span class="hljs-string">"where id=#&#123;id&#125;"</span>,</span>  "<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>"&#125;)void updateAuthorValues(Author author);</code></pre><p>bind<br>-<code>bind</code> 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">select</span> id="selectBlogsLike" resultType="Blog"&gt;  &lt;bind <span class="hljs-type">name</span>="pattern" <span class="hljs-keyword">value</span>="'%' + _parameter.getTitle() + '%'" /&gt;  <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> BLOG  <span class="hljs-keyword">WHERE</span> title <span class="hljs-keyword">LIKE</span> #&#123;pattern&#125;&lt;/<span class="hljs-keyword">select</span>&gt;</code></pre><p>模糊查询like的三种方式：<br>1、直接在参数上拼接%</p><p>2、使用concat()函数做字符串拼接</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> orders <span class="hljs-keyword">where</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">like</span> <span class="hljs-keyword">concat</span>(<span class="hljs-keyword">concat</span>(‘%’, <span class="hljs-comment">#&#123;number&#125;),’%’)</span></code></pre><p>3、bind标签</p><p>select * from orders where number like #{ll}</p><h4 id="当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h4><ul><li><p>写sql语句时起别名</p></li><li><p>在MyBatis的全局配置文件中开启驼峰命名规则</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 开启驼峰命名规则，可以将数据库中的下划线映射为驼峰命名 --&gt;</span>        <span class="hljs-comment">&lt;!-- 例如：dept_id 可以映射为deptId --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mapUndercoreToCamelCase"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">setting</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>1234567</code></pre></li><li><p>在Mapper映射文件中使用resultMap来自定义映射规则</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getOrder"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"orderresultmap"</span>&gt;</span></span><span class="xml">select * from orders where order_id=#</span><span class="hljs-template-variable">&#123;id&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">”me.gacl.domain.order”</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”orderresultmap”</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">!–用id属性来映射主键字段–</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">”id”</span> <span class="hljs-attr">column</span>=<span class="hljs-string">”order_id”</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span> = <span class="hljs-string">“orderno”</span> <span class="hljs-attr">column</span> =<span class="hljs-string">”order_no”/</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">”price”</span> <span class="hljs-attr">column</span>=<span class="hljs-string">”order_price”</span> /&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">reslutMap</span>&gt;</span></span></code></pre></li></ul><h4 id="问-和-的区别是什么？"><a href="#问-和-的区别是什么？" class="headerlink" title="问{}和${}的区别是什么？"></a>问{}和${}的区别是什么？</h4><p>#{}是预编译处理，${}是字符串替换。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h2 id="MyBatis其他问题"><a href="#MyBatis其他问题" class="headerlink" title="MyBatis其他问题"></a>MyBatis其他问题</h2><h3 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h3><p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p><p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。</p><p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。</p><h3 id="什么是MyBatis的接口绑定-有什么好处"><a href="#什么是MyBatis的接口绑定-有什么好处" class="headerlink" title="什么是MyBatis的接口绑定,有什么好处"></a>什么是MyBatis的接口绑定,有什么好处</h3><p>答：接口映射就是在IBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><p>接口绑定有几种实现方式,分别是怎么实现的?<br>答：接口绑定有两种实现方式：</p><p>一种是通过注解绑定，就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定。<br>另外一种就是通过xml里面写SQL来绑定，在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。<br>什么情况下用注解绑定,什么情况下用xml绑定<br>当Sql语句比较简单时候,用注解绑定。<br>当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</p><h3 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h3><p>答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10</p><h3 id="简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>简述Mybatis的插件运行原理，以及如何编写一个插件。</h3><p>答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis 简介</title>
    <link href="/2020/08/31/Mbatis%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/08/31/Mbatis%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-简介"><a href="#Mybatis-简介" class="headerlink" title="Mybatis 简介"></a>Mybatis 简介</h1><hr><h1 id="什么是-MyBatis-？"><a href="#什么是-MyBatis-？" class="headerlink" title="什么是 MyBatis ？"></a>什么是 MyBatis ？</h1><ul><li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li><li>MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</li></ul><hr><h1 id="MyBatis如何安装？"><a href="#MyBatis如何安装？" class="headerlink" title="MyBatis如何安装？"></a>MyBatis如何安装？</h1><ul><li>要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于 classpath 中即可。</li><li>如果使用 Maven 来构建项目，则需将下面的 dependency 代码置于 pom.xml 文件中：<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.x.x<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li></ul><hr><h1 id="MyBatis的功能架构"><a href="#MyBatis的功能架构" class="headerlink" title="MyBatis的功能架构"></a>MyBatis的功能架构</h1><p>Mybatis的功能架构可以分为三层：API接口层、数据处理层、基础支撑层</p><ul><li><code>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</code></li><li><code>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</code></li><li><code>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</code></li></ul><hr><h1 id="MyBatis的优缺点"><a href="#MyBatis的优缺点" class="headerlink" title="MyBatis的优缺点"></a>MyBatis的优缺点</h1><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 </li><li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能，或许更多。 </li><li>解除sql与程序代码的耦合：通过提供DAL层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 </li><li>提供映射标签，支持对象与数据库的orm字段关系映射 </li><li>提供对象关系映射标签，支持对象关系组建维护 </li><li>提供xml标签，支持编写动态sql。 </li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>编写SQL语句时工作量很大，尤其是字段多、关联表多时，更是如此。 </li><li>SQL语句依赖于数据库，导致数据库移植性差，不能更换数据库。 </li><li>框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。 </li><li>二级缓存机制不佳</li></ul><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Mybatis是目前主流的处于DAO层的框架，它虽然会有一些缺点，但目前来说，它会是一个你比较好的选择。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC（二） @RequestMapping </title>
    <link href="/2020/08/26/SpringMVC%EF%BC%88%E4%BA%8C%EF%BC%89-RequestMapping/"/>
    <url>/2020/08/26/SpringMVC%EF%BC%88%E4%BA%8C%EF%BC%89-RequestMapping/</url>
    
    <content type="html"><![CDATA[<h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h1><h2 id="1-RequestMapping-映射请求注解"><a href="#1-RequestMapping-映射请求注解" class="headerlink" title="1. @RequestMapping 映射请求注解"></a>1. @RequestMapping 映射请求注解</h2><ul><li><code>SpringMVC 使用@RequestMapping 注解为控制器指定可以处理哪些 URL 请求</code></li><li><code>在控制器的 类定义及方法定义处都可标注 @RequestMapping</code><blockquote><p>标记在类上：提供初步的请求映射信息。相对于 WEB 应用的根目录。</p></blockquote></li></ul><blockquote><p>标记在方法上：提供进一步的细分映射信息。相对于标记在类上的 URL。</p></blockquote><ul><li><p><code>若类上未标注 @RequestMapping，则方法处标记的 URL 相对于 WEB 应用的根目录</code></p></li><li><p>作用</p></li></ul><p>DispatcherServlet 截获请求后，就通过控制器上 @RequestMapping 提供的<br>映射信息确定请求所对应的处理方法。</p><hr><h2 id="2-RequestMapping属性"><a href="#2-RequestMapping属性" class="headerlink" title="2. @RequestMapping属性"></a>2. @RequestMapping属性</h2><p> 参考文章 <a href="https://blog.csdn.net/qq_23090489/article/details/93322403" target="_blank" rel="noopener">@RequestMapping注解</a></p><hr><h2 id="3-RequestMapping支持-Ant-路径风格"><a href="#3-RequestMapping支持-Ant-路径风格" class="headerlink" title="3. @RequestMapping支持 Ant 路径风格"></a>3. @RequestMapping支持 Ant 路径风格</h2><ul><li><code>Ant 持 风格资源地址支持 3 种匹配符</code></li></ul><pre><code class="hljs asciidoc">? ：匹配文件名中的一个字符<span class="hljs-bullet">* </span>：匹配文件名中的任意字符<span class="hljs-bullet">** </span>：** 匹配多层路径</code></pre><ul><li><code>Ant风格URL</code><pre><code class="hljs jboss-cli"><span class="hljs-string">/user/</span>*<span class="hljs-string">/createUser</span>匹配 <span class="hljs-string">/user/aaa/createUser</span>、<span class="hljs-string">/user/bbb/createUser</span> 等 URL<span class="hljs-string">/user/</span>**<span class="hljs-string">/createUser</span>匹配 <span class="hljs-string">/user/createUser</span>、<span class="hljs-string">/user/aaa/bbb/createUser</span> 等 URL<span class="hljs-string">/user/createUser</span>??匹配 <span class="hljs-string">/user/createUseraa</span>、<span class="hljs-string">/user/createUserbb</span> 等 URL</code></pre></li></ul><h2 id="4-PathVariable注解"><a href="#4-PathVariable注解" class="headerlink" title="4. @PathVariable注解"></a>4. @PathVariable注解</h2><ul><li><p><code>带占位符的 URL 是 是 Spring3.0 新增的功能</code></p></li><li><p><code>通过 @PathVariable 将 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：</code></p><pre><code class="hljs kotlin">URL 中的 &#123;xxx&#125; 占位符可以通过 <span class="hljs-meta">@PathVariable(<span class="hljs-meta-string">"xxx"</span>)</span> 绑定到操作方法的入参中。</code></pre></li><li><p>例子</p><pre><code class="hljs kotlin"><span class="hljs-meta">@RequestMapping(value=<span class="hljs-meta-string">"/testPathVariable/&#123;id&#125;"</span>)</span><span class="hljs-keyword">public</span> String testPathVariable(<span class="hljs-meta">@PathVariable(<span class="hljs-meta-string">"id"</span>)</span> Integer id)&#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"testPathVariable...id="</span>+id);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring MVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC（一）概述</title>
    <link href="/2020/08/26/SpringMVC%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/08/26/SpringMVC%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-MVC-概述"><a href="#Spring-MVC-概述" class="headerlink" title="Spring MVC 概述"></a>Spring MVC 概述</h1><blockquote><p>写在前面：MVC系列文章，主要介绍一些关于Spring MVC的使用和内容。关于Spring MVC的综合应用，放在之后专门的文章中进行描述。</p></blockquote><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><ul><li><code>1 Spring 为展现层提供的基于 MVC 设计理念的优秀的 Web 框架，是目前最主流的MVC 框架之一。</code></li><li><code>2 Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架。</code></li><li><code>3 Spring MVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，而无须实现任何接口。</code></li><li><code>4 支持 REST 风格的 URL 请求。</code></li><li><code>5 采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性。</code></li></ul><hr><h2 id="2-具体一点"><a href="#2-具体一点" class="headerlink" title="2. 具体一点"></a>2. 具体一点</h2><ul><li><p><code>一种轻量级的、基于 MVC 的 的 Web 层应用框架。偏前端而不是基于业务逻辑层。</code></p></li><li><p><code>是 Spring 框架的一个后续产品。</code></p></li><li><p>Spring 框架结构图(新版本)：<br><img src="https://s1.ax1x.com/2020/08/26/dRS91S.png" srcset="/img/loading.gif" alt="pic"></p></li><li><p>Spring 框架结构图(老版本)：<br><img src="https://s1.ax1x.com/2020/08/26/dRSpp8.png" srcset="/img/loading.gif" alt="pic"></p></li></ul><hr><h2 id="3-功能-优势"><a href="#3-功能-优势" class="headerlink" title="3. 功能-优势"></a>3. 功能-优势</h2><ul><li><code>* 天生与 Spring 框架集成，如：(IOC,AOP)</code></li><li><code>* 支持 Restful 风格</code></li><li><code>* 进行更简洁的 Web 层开发</code></li><li><code>* 支持灵活的 URL 到页面控制器的映射</code></li><li><code>非常容易与其他视图技术集成，如:Velocity、FreeMarker 等等。</code></li><li><code>因为模型数据不存放在特定的 API 里，而是放在一个 Model 里(Map 数据结构实现，因此很容易被其他框架使用)</code></li><li><code>非常灵活的数据验证、格式化和数据绑定机制、能使用任何对象进行数据绑定，不必实现特定框架的 API</code></li><li><code>更加简单、强大的异常处理</code></li><li><code>对静态资源的支持</code></li><li><code>支持灵活的本地化、主题等解析</code></li></ul><hr><h2 id="4-jar包"><a href="#4-jar包" class="headerlink" title="4. jar包"></a>4. jar包</h2><p>在Spring的基础jar包上（参见Spring系列文章），多了一个</p><pre><code class="hljs css"><span class="hljs-selector-tag">spring-webmvc-x</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.release</span><span class="hljs-selector-class">.jar</span></code></pre><hr><h2 id="5-SpringMVC架构"><a href="#5-SpringMVC架构" class="headerlink" title="5. SpringMVC架构"></a>5. SpringMVC架构</h2><ul><li>将 Web 层进行了职责解耦，也就和 struts2 一样，基于请求-响应模型</li><li>常用主要组件</li></ul><blockquote><p>DispatcherServlet：前端控制器</p></blockquote><blockquote><p>Controller：处理器/页面控制器，做的是 MVC 中的 C 的事情，但控制逻辑转移<br>到前端控制器了，用于对请求进行处理</p></blockquote><blockquote><p>HandlerMapping ：请求映射到处理器，找谁来处理，如果映射成功返回一个<br>HandlerExecutiongChain 对象（包含一个 Handler 处理器(页面控制器)对象、多<br>个 HandlerInterceptor 拦截器对象）</p></blockquote><blockquote><p>ViewResolver : 视图解析器，找谁来处理返回的页面。把逻辑视图解析为具体<br>的 View,进行这种策略模式，很容易更换其他视图技术； 如InternalResourceViewResolver 将逻辑视图名映射为 JSP 视图。</p></blockquote><blockquote><p>LocalResolver：本地化、国际化</p></blockquote><blockquote><p>MultipartResolver：文件上传解析器</p></blockquote><blockquote><p>HandlerExceptionResolver：异常处理器</p></blockquote><h2 id="6-Spring-MVC快速入门"><a href="#6-Spring-MVC快速入门" class="headerlink" title="6. Spring MVC快速入门"></a>6. Spring MVC快速入门</h2><ul><li><p>新建 Web 工程，加入 jar 包</p><pre><code class="hljs angelscript"><span class="hljs-comment">// Spring相关</span>spring-aop<span class="hljs-number">-4.0</span><span class="hljs-number">.0</span>.RELEASE.jarspring-beans<span class="hljs-number">-4.0</span><span class="hljs-number">.0</span>.RELEASE.jarspring-context<span class="hljs-number">-4.0</span><span class="hljs-number">.0</span>.RELEASE.jarspring-core<span class="hljs-number">-4.0</span><span class="hljs-number">.0</span>.RELEASE.jarspring-expression<span class="hljs-number">-4.0</span><span class="hljs-number">.0</span>.RELEASE.jarcommons-logging<span class="hljs-number">-1.1</span><span class="hljs-number">.3</span>.jar<span class="hljs-comment">// web相关</span>spring-web<span class="hljs-number">-4.0</span><span class="hljs-number">.0</span>.RELEASE.jarspring-webmvc<span class="hljs-number">-4.0</span><span class="hljs-number">.0</span>.RELEASE.jar</code></pre><p>特别的，基于Maven的工程只需要导入依赖坐标，关于Maven的使用，这里不展开表述。</p><ul><li>在 web.xml 中配置 DispatcherServlet</li></ul><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- 配置 SpringMVC 核心控制器： --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置 DispatcherServlet 的初始化參數：设置文件的路径和文件名称 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 告知拦截器，SpringMVC的配置文件的位置 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-comment">&lt;!--映射，对于/下所有请求都先拦截再处理 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></li></ul><p>注意：实际上也可以不通过 contextConfigLocation 来配置 SpringMVC 的配置文件, 而使用默认的。默认的配置文件为: /WEB-INF/<servlet-name>-servlet.xml。</p><ul><li>配置Spring MVC：springmvc.xml</li></ul><p><code>增加名称空间</code><br><img src="https://s1.ax1x.com/2020/08/26/dRSPXQ.png" srcset="/img/loading.gif" alt="pic"></p><p><code>增加配置</code></p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 设置扫描组件的包： --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.atguigu.springmvc"</span>/&gt;</span><span class="hljs-comment">&lt;!-- 配置映射解析器：如何将控制器返回的结果字符串，转换为一个物理的视图文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"internalResourceViewResolver"</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/views/"</span>/&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><ul><li><p>创建一个入口页面，index.jsp</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!--index.jsp内容--&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;pageContext.request.contextPath &#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">/helloworld"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span></code></pre></li><li><p>编写处理请求的处理器，并标识为处理器</p></li></ul><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.atguigu.springmvc.controller;<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestMapping;<span class="hljs-meta">@Controller</span> <span class="hljs-comment">//声明 Bean 对象，为一个控制器组件</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldController</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment">* 映射请求的名称：</span><span class="hljs-comment">* 1. 使用 <span class="hljs-doctag">@RequestMapping</span> 注解来映射请求的 URL</span><span class="hljs-comment">* 2. 返回值会通过视图解析器解析为实际的物理视图, 对于InternalResourceViewResolver 视图解析器,会做如下的解析:</span><span class="hljs-comment"></span><span class="hljs-comment">* 通过 prefix + returnVal + suffix 这样的方式得到实际的物理视图, 然后做转发操作.</span><span class="hljs-comment">* /WEB-INF/views/success.jsp</span><span class="hljs-comment">*/</span>  <span class="hljs-meta">@RequestMapping(value=<span class="hljs-meta-string">"/helloworld"</span>,method=RequestMethod.GET)</span>  <span class="hljs-keyword">public</span> String helloworld()&#123;    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"hello,world"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>; <span class="hljs-comment">//结果如何跳转呢？需要配置映射解析器</span>  &#125;&#125;</code></pre><ul><li><p>编写视图:/WEB-INF/views/success.jsp</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>Sucess Page<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></code></pre></li><li><p>部署测试</p></li></ul><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/快速入门/i</span>ndex.jsp</code></pre><hr><h2 id="7-案例解析"><a href="#7-案例解析" class="headerlink" title="7. 案例解析"></a>7. 案例解析</h2><ul><li><p>请求流程图解<br><img src="https://s1.ax1x.com/2020/08/26/dRSC6g.png" srcset="/img/loading.gif" alt="pic"></p></li><li><p>一般请求的映射路径名称和处理请求的方法名称最好一致（实质上方法名称任意）</p><pre><code class="hljs pgsql">@RequestMapping(<span class="hljs-keyword">value</span>="/helloworld",<span class="hljs-keyword">method</span>=RequestMethod.<span class="hljs-keyword">GET</span>)<span class="hljs-built_in">public</span> String helloworld()&#123;//<span class="hljs-built_in">public</span> String abc123()&#123;    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("hello,world");    <span class="hljs-keyword">return</span> "success";&#125;</code></pre></li><li><p>@RequestMapping</p></li></ul><p><code>可以用在类上和方法上, 作用于类可以认为是一级访问路径，方法上可以认为是二级访问路径</code></p><p><code>粗略的讲，如果没有作用在类上的，则方法上的就是一级访问路径</code></p><ul><li><p>流程图示<br><img src="https://s1.ax1x.com/2020/08/26/dRSFmj.png" srcset="/img/loading.gif" alt="pic"></p></li><li><p>基本步骤</p></li><li><p><code>客户端请求提交到 DispatcherServlet</code></p></li><li><p><code>由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的Controller</code></p></li><li><p><code>DispatcherServlet 将请求提交到 Controller（也称为 Handler）</code></p></li><li><p><code>Controller 调用业务逻辑处理后，返回 ModelAndView</code></p></li><li><p><code>DispatcherServlet 查询一个或多个 ViewResoler 视图解析器，找到 ModelAndView 指定的视图</code></p></li><li><p><code>视图负责将结果显示到客户端</code></p></li></ul><p>总的来说，在这里，DispatcherServlet（前端控制器）起到了关键作用，你可以认为他是一个统筹调度的角色。关于其他的组件，目前不必深究，后面再探讨。</p>]]></content>
    
    
    <categories>
      
      <category>Spring MVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring号外 - Spring JdbcTemplate</title>
    <link href="/2020/08/25/Spring%E5%8F%B7%E5%A4%96-Spring-JdbcTemplate/"/>
    <url>/2020/08/25/Spring%E5%8F%B7%E5%A4%96-Spring-JdbcTemplate/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-JdbcTemplate"><a href="#Spring-JdbcTemplate" class="headerlink" title="Spring JdbcTemplate"></a>Spring JdbcTemplate</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><code>为了使 JDBC 更加易于使用，Spring 在 JDBC API 上定义了一个抽象层，以此建立一个 JDBC 存取框架。</code></li><li><code>作为 Spring JDBC 框架的核心，JDBC 模板的设计目的是为不同类型的 JDBC 操作提供模板方法，通过这种方式，可以在尽可能保留灵活性的情况下，将数据库存取的工作量降到最低。</code></li><li><code>可以将 Spring 的 JdbcTemplate 看作是一个小型的轻量级持久化层框架。</code></li></ul><hr><h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备</h2><ul><li>导入 JAR 包</li></ul><pre><code class="hljs css">①<span class="hljs-selector-tag">IOC</span> 容器所需要的 <span class="hljs-selector-tag">JAR</span> 包<span class="hljs-selector-tag">commons-logging-1</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-beans-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-context-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-core-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-expression-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span>②<span class="hljs-selector-tag">JdbcTemplate</span> 所需要的 <span class="hljs-selector-tag">JAR</span> 包<span class="hljs-selector-tag">spring-jdbc-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-orm-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-tx-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span>③数据库驱动和数据源<span class="hljs-selector-tag">c3p0-0</span><span class="hljs-selector-class">.9</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.2</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">mysql-connector-java-5</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.7-bin</span><span class="hljs-selector-class">.jar</span></code></pre><ul><li>创建连接数据库基本信息属性文件</li></ul><pre><code class="hljs ini"><span class="hljs-attr">user</span>=root<span class="hljs-attr">password</span>=root<span class="hljs-attr">jdbcUrl</span>=jdbc:mysql:///query_data<span class="hljs-attr">driverClass</span>=com.mysql.jdbc.Driver<span class="hljs-attr">initialPoolSize</span>=<span class="hljs-number">30</span><span class="hljs-attr">minPoolSize</span>=<span class="hljs-number">10</span><span class="hljs-attr">maxPoolSize</span>=<span class="hljs-number">100</span><span class="hljs-attr">acquireIncrement</span>=<span class="hljs-number">5</span><span class="hljs-attr">maxStatements</span>=<span class="hljs-number">1000</span><span class="hljs-attr">maxStatementsPerConnection</span>=<span class="hljs-number">10</span></code></pre><ul><li>在 Spring 配置文件中配置相关的 bean</li></ul><p>①数据源对象</p><pre><code class="hljs applescript">&lt;context:<span class="hljs-keyword">property</span>-placeholder location=<span class="hljs-string">"classpath:jdbc.properties"</span>/&gt;&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;  &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"user"</span> value=<span class="hljs-string">"$&#123;user&#125;"</span>/&gt;  &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"password"</span> value=<span class="hljs-string">"$&#123;password&#125;"</span>/&gt;  &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"jdbcUrl"</span> value=<span class="hljs-string">"$&#123;jdbcUrl&#125;"</span>/&gt;  &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"driverClass"</span> value=<span class="hljs-string">"$&#123;driverClass&#125;"</span>/&gt;  &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"initialPoolSize"</span> value=<span class="hljs-string">"$&#123;initialPoolSize&#125;"</span>/&gt;  &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"minPoolSize"</span> value=<span class="hljs-string">"$&#123;minPoolSize&#125;"</span>/&gt;  &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"maxPoolSize"</span> value=<span class="hljs-string">"$&#123;maxPoolSize&#125;"</span>/&gt;  &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"acquireIncrement"</span> value=<span class="hljs-string">"$&#123;acquireIncrement&#125;"</span>/&gt;  &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"maxStatements"</span> value=<span class="hljs-string">"$&#123;maxStatements&#125;"</span>/&gt;  &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"maxStatementsPerConnection"</span> value=<span class="hljs-string">"$&#123;maxStatementsPerConnection&#125;"</span>/&gt;&lt;/bean&gt;</code></pre><p>②JdbcTemplate 对象</p><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">"template"</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;&lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;&lt;/bean&gt;</code></pre><hr><h2 id="3-持久化操作"><a href="#3-持久化操作" class="headerlink" title="3. 持久化操作"></a>3. 持久化操作</h2><ul><li><p>增删改</p><pre><code class="hljs n1ql">JdbcTemplate.<span class="hljs-keyword">update</span>(<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Object</span>...)</code></pre></li><li><p>批量增删改</p></li></ul><pre><code class="hljs dart">JdbcTemplate.batchUpdate(<span class="hljs-built_in">String</span>, <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>[]&gt;)  <span class="hljs-built_in">Object</span>[]封装了 SQL 语句每一次执行时所需要的参数  <span class="hljs-built_in">List</span> 集合封装了 SQL 语句多次执行时的所有参数</code></pre><ul><li>查询单行<pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdbcTemplate</span>.</span></span>query<span class="hljs-constructor">ForObject(String, RowMapper&lt;Department&gt;, Object<span class="hljs-operator">...</span>)</span></code></pre></li></ul><p><img src="https://s1.ax1x.com/2020/08/25/dgH2uV.png" srcset="/img/loading.gif" alt="pic"></p><ul><li><p>查询多行</p><pre><code class="hljs dart">JdbcTemplate.query(<span class="hljs-built_in">String</span>, RowMapper&lt;Department&gt;, <span class="hljs-built_in">Object</span>...)RowMapper 对象依然可以使用 BeanPropertyRowMapper</code></pre></li><li><p>查询单一值</p><pre><code class="hljs delphi">JdbcTemplate.queryForObject(<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Class</span>, <span class="hljs-keyword">Object</span>...)</code></pre></li></ul><p>值得一提的是，上述查询所得到的的结果集，Spring JDBC Template 使用BeanPropertyRowMapper来进行封装。我们只需要将返回值类型告知即可。例如：我们查询单一Employee信息。</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdbcTemplate</span>.</span></span>query<span class="hljs-constructor">ForObject(<span class="hljs-string">"SQL"</span>, <span class="hljs-params">new</span> BeanPropertyRowMapper&lt;&gt;(Employee.<span class="hljs-params">class</span>)</span>, Object...)</code></pre><hr><h2 id="4-使用-JdbcTemplate-实现-Dao"><a href="#4-使用-JdbcTemplate-实现-Dao" class="headerlink" title="4. 使用 JdbcTemplate 实现 Dao"></a>4. 使用 JdbcTemplate 实现 Dao</h2><ul><li>通过 IOC 容器自动注入<blockquote><p>JdbcTemplate 类是线程安全的，所以可以在 IOC 容器中声明它的单个实例，并<br>将这个实例注入到所有的 Dao 实例中。</p></blockquote></li></ul><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDao</span> </span>&#123;  <span class="hljs-meta">@Autowired</span>  <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> Employee <span class="hljs-title">get</span><span class="hljs-params">(Integer id)</span></span>&#123;  <span class="hljs-comment">//…</span>  &#125;&#125;</code></pre><hr><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本文介绍了Spring JDBC Template的基本使用。更多细节操作，可自行查阅资料。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础（六）声明式事务</title>
    <link href="/2020/08/25/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2020/08/25/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring声明式事务"><a href="#Spring声明式事务" class="headerlink" title="Spring声明式事务"></a>Spring声明式事务</h1><h2 id="1-事务概述"><a href="#1-事务概述" class="headerlink" title="1. 事务概述"></a>1. 事务概述</h2><ul><li><code>在 JavaEE 企业级开发的应用领域，为了保证数据的 完整性和 一致性，必须引入数据库事务的概念，所以事务管理是企业级应用程序开发中必不可少的技术。</code></li><li><code>事务就是一组由于逻辑上紧密关联而合并成一个整体(工作单元)的多个数据库操作，这些操作 要么都执行， 要么都不执行。</code></li><li><code>事务的四个关键属性(ACID)</code></li></ul><blockquote><p>原子性(atomicity): 事务的原子性要求事务中的所有操<br>作要么都执行，要么都不执行。</p></blockquote><blockquote><p>一致性(consistency): 一个事务中不管涉及到多少个操作，都必须保证事务执行之前数据是正确的，事务执行之后数据仍然是正确的。 如果出现错误，应该整个事务回滚。</p></blockquote><blockquote><p>隔离性(isolation)：隔离性原则要求多个事务在 并发执行过程中不会互相干扰。</p></blockquote><blockquote><p>持久性(durability)：持久性原则要求事务执行完成后，对数据的修改 永久的<br>保存下来，不会因各种系统错误或其他意外情况而受到影响。</p></blockquote><hr><h2 id="2-Spring-事务管理"><a href="#2-Spring-事务管理" class="headerlink" title="2. Spring 事务管理"></a>2. Spring 事务管理</h2><h3 id="2-1-编程式事务管理-回顾"><a href="#2-1-编程式事务管理-回顾" class="headerlink" title="2.1 编程式事务管理(回顾)"></a>2.1 编程式事务管理(回顾)</h3><p>①使用原生的 JDBC API 进行事务管理</p><ul><li><code>[1]获取数据库连接 Connection 对象</code></li><li><code>[2]取消事务的自动提交</code></li><li><code>[3]执行操作</code></li><li><code>[4]正常完成操作时手动提交事务</code></li><li><code>[5]执行失败时回滚事务</code></li><li><code>[6]关闭相关资源</code></li></ul><p>②评价</p><ul><li><code>嵌入到业务方法中, 造成代码耦合度高</code></li><li><code>会造成较大程度的 代码冗余。</code></li></ul><h3 id="2-2-声明式事务管理"><a href="#2-2-声明式事务管理" class="headerlink" title="2.2 声明式事务管理"></a>2.2 声明式事务管理</h3><p>事务管理代码的 固定模式 作为一种 横切关注点，可以通过 AOP 方法模块化，<br>助 进而借助 Spring AOP 框架实现声明式事务管理。</p><h3 id="2-3-Spring-提供的事务管理器"><a href="#2-3-Spring-提供的事务管理器" class="headerlink" title="2.3 Spring 提供的事务管理器"></a>2.3 Spring 提供的事务管理器</h3><ul><li><code>Spring 的核心事务管理抽象是 PlatformTransactionManager。它为事务管理封装了一组独立于技术的方法。无论使用 Spring 的哪种事务管理策略(编程式或声明式)，事务管理器都是必须的。</code></li><li><code>事务管理器可以以普通的 bean 的形式声明在 Spring IOC 容器中。</code></li></ul><h3 id="2-4-事务管理器的主要实现"><a href="#2-4-事务管理器的主要实现" class="headerlink" title="2.4  事务管理器的主要实现"></a>2.4  事务管理器的主要实现</h3><p>①DataSourceTransactionManager：在应用程序中只需要处理一个数据源，而且<br>通过 JDBC 存取。</p><p>②JtaTransactionManager：在 JavaEE 应用服务器上用 JTA(Java Transaction API)<br>进行事务管理</p><p>③HibernateTransactionManager：用 Hibernate 框架存取数据库</p><p><img src="https://s1.ax1x.com/2020/08/25/dgIBSP.png" srcset="/img/loading.gif" alt="pic"></p><hr><h2 id="3-基于注解的声明式事务配置"><a href="#3-基于注解的声明式事务配置" class="headerlink" title="3. 基于注解的声明式事务配置"></a>3. 基于注解的声明式事务配置</h2><ul><li>值得一提的是，无论是XML配置，还是注解配置，事务管理器都是必不可少的，需要在Spring配置文件中，以bean的形式配置。</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- 启用事务注解 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>/&gt;</span></code></pre><ul><li>在需要进行事务控制的方法上加注解</li><li><code>@Transactional</code></li></ul><blockquote><p>简单的两步配置，即可完成对事务的控制</p></blockquote><hr><h2 id="4-基于XML的声明式事务配置"><a href="#4-基于XML的声明式事务配置" class="headerlink" title="4. 基于XML的声明式事务配置"></a>4. 基于XML的声明式事务配置</h2><ul><li>事务管理器的配置如上述配置一致，这里不再赘述。</li></ul><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置事务切面 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(* com.atguigu.tx.component.service.BookShopServiceImpl.purchase(..))"</span></span><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">"txPointCut"</span>/&gt;</span>  <span class="hljs-comment">&lt;!-- 将切入点表达式和事务属性配置关联到一起 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"myTx"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"txPointCut"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><span class="hljs-comment">&lt;!-- 配置基于 XML 的声明式事务 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myTx"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 设置具体方法的事务属性 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"find*"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"get*"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"purchase"</span></span><span class="hljs-tag">    <span class="hljs-attr">isolation</span>=<span class="hljs-string">"READ_COMMITTED"</span></span><span class="hljs-tag">    <span class="hljs-attr">no-rollback-for</span>=<span class="hljs-string">"java.lang.ArithmeticException,java.lang.NullPointerException"</span></span><span class="hljs-tag">    <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRES_NEW"</span></span><span class="hljs-tag">    <span class="hljs-attr">read-only</span>=<span class="hljs-string">"false"</span></span><span class="hljs-tag">    <span class="hljs-attr">timeout</span>=<span class="hljs-string">"10"</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></code></pre><hr><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>本文主要介绍了Spring两种声明式事务的配置方式（注解/XML）,有关数据库事务的细节、Spring事务属性的详细内容，见后续文章。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础（五）AOP-XML配置</title>
    <link href="/2020/08/25/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89AOP-XML%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/08/25/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89AOP-XML%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="以-XML-方式配置切面"><a href="#以-XML-方式配置切面" class="headerlink" title="以 XML 方式配置切面"></a>以 XML 方式配置切面</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><p>需知：除了使用 AspectJ 注解声明切面，Spring 也支持在 bean 配置文件中声明切面。这种声明是通过 aop 名称空间中的 XML 元素完成的。</p></li><li><p>正常情况下，基于注解的声明要优先于基于 XML 的声明。通过 AspectJ 注解，切面<br>可以与 AspectJ 兼容，而基于 XML 的配置则是 Spring 专有的。由于 AspectJ 得到越来越多的 AOP 框架支持，所以以注解风格编写的切面将会有更多重用的机会。</p></li></ul><hr><h2 id="2-配置细节"><a href="#2-配置细节" class="headerlink" title="2. 配置细节"></a>2. 配置细节</h2><ul><li>在 bean 配置文件中，所有的 Spring AOP 配置都必须定义在<a href="aop:config">aop:config</a>元素内部。</li><li>对于每个切面而言，都要创建一个<a href="aop:aspect">aop:aspect</a>元素来为具体的切面实现引用后端 bean实例。</li><li>切面 bean 必须有一个标识符，供<a href="aop:aspect">aop:aspect</a>元素引用。</li></ul><p><img src="https://s1.ax1x.com/2020/08/25/dghDQU.png" srcset="/img/loading.gif" alt="pic"></p><hr><h2 id="3-声明切入点"><a href="#3-声明切入点" class="headerlink" title="3. 声明切入点"></a>3. 声明切入点</h2><ul><li><code>切入点使用&lt;aop:pointcut&gt;元素声明。</code></li><li><code>切入点必须定义在&lt;aop:aspect&gt;元素下，或者直接定义在&lt;aop:config&gt;元素下。</code><blockquote><p>定义在<a href="aop:aspect">aop:aspect</a>元素下：只对当前切面有效<br>定义在<a href="aop:config">aop:config</a>元素下：对所有切面都有效</p></blockquote></li><li><code>基于 XML 的 AOP 配置不允许在切入点表达式中用名称引用其他切入点。</code></li></ul><p><img src="https://s1.ax1x.com/2020/08/25/dgh0zT.png" srcset="/img/loading.gif" alt="pic"></p><hr><h2 id="4-声明通知"><a href="#4-声明通知" class="headerlink" title="4. 声明通知"></a>4. 声明通知</h2><ul><li><code>在 aop 名称空间中，每种通知类型都对应一个特定的 XML 元素。</code></li><li><code>通知元素需要使用&lt;pointcut-ref&gt;来引用切入点，或用&lt;pointcut&gt;直接嵌入切入点表达式。</code></li><li><code>method 属性指定切面类中通知方法的名称</code></li></ul><p><img src="https://s1.ax1x.com/2020/08/25/dghsL4.png" srcset="/img/loading.gif" alt="pic"></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础（四）AOP细节</title>
    <link href="/2020/08/24/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89AOP%E7%BB%86%E8%8A%82/"/>
    <url>/2020/08/24/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89AOP%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP细节"><a href="#AOP细节" class="headerlink" title="AOP细节"></a>AOP细节</h1><blockquote><p>本文基于注解配置AOP</p></blockquote><h2 id="1-切入点表达式（Point-Cut-Expression）"><a href="#1-切入点表达式（Point-Cut-Expression）" class="headerlink" title="1.切入点表达式（Point-Cut Expression）"></a>1.切入点表达式（Point-Cut Expression）</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><blockquote><p>通过 表达式的方式定位 一个或多个具体的连接点。</p></blockquote><h3 id="语法细节"><a href="#语法细节" class="headerlink" title="语法细节"></a>语法细节</h3><p>①切入点表达式的语法格式</p><pre><code class="hljs markdown">execution([<span class="hljs-string">权限修饰符</span>] [<span class="hljs-string">返回值类型</span>] [<span class="hljs-string">简单类名/全类名</span>] [<span class="hljs-string">方法名</span>](<span class="hljs-link">[参数列表]</span>))</code></pre><p>②举例说明</p><table><thead><tr><th>表达式</th><th>execution(* com.atguigu.spring.ArithmeticCalculator.*(..))</th></tr></thead><tbody><tr><td>含义</td><td>ArithmeticCalculator 接口中声明的所有方法。</td></tr><tr><td></td><td>第一个“*”代表任意修饰符及任意返回值</td></tr><tr><td></td><td>第二个“*”代表任意方法。</td></tr><tr><td></td><td>“..”匹配任意数量、任意类型的参数。</td></tr><tr><td></td><td>若目标类、接口与该切面类在同一个包中可以省略包名。</td></tr></tbody></table><table><thead><tr><th>表达式</th><th>execution(public * ArithmeticCalculator.*(..))</th></tr></thead><tbody><tr><td>含义</td><td>ArithmeticCalculator 接口的所有公有方法</td></tr></tbody></table><table><thead><tr><th>表达式</th><th>execution(public double ArithmeticCalculator.*(..))</th></tr></thead><tbody><tr><td>含义</td><td>ArithmeticCalculator 接口中返回 double 类型数值的方法</td></tr></tbody></table><table><thead><tr><th>表达式</th><th>execution(public double ArithmeticCalculator.*(double, ..))</th></tr></thead><tbody><tr><td>含义</td><td>第一个参数为 double 类型的方法</td></tr><tr><td></td><td>“..” 匹配任意数量、任意类型的参数。</td></tr></tbody></table><table><thead><tr><th>表达式</th><th>execution(public double ArithmeticCalculator.*(double, double))</th></tr></thead><tbody><tr><td>含义</td><td>参数类型为 double，double 类型的方法</td></tr></tbody></table><p><strong><em>特别的</em></strong></p><blockquote><p>在 AspectJ 中，切入点表达式可以通过 “&amp;&amp;”、“||”、“!”等操作符结合起来。下面用or代替||，这是由于markdown语法中含有|，我转义字符也没得用，就这样写下，意思就是这样啦</p></blockquote><table><thead><tr><th>表达式</th><th>execution (* *.add(int,..)) or execution(* *.sub(int,..))</th></tr></thead><tbody><tr><td>含义</td><td>任意类中第一个参数为 int 类型的 add 方法或 sub 方法</td></tr></tbody></table><h3 id="切入点表达式应用到实际的切面类中"><a href="#切入点表达式应用到实际的切面类中" class="headerlink" title="切入点表达式应用到实际的切面类中"></a>切入点表达式应用到实际的切面类中</h3><p><img src="https://s1.ax1x.com/2020/08/24/dyUtgS.png" srcset="/img/loading.gif" alt="pic"></p><hr><h3 id="2-JoinPoint细节"><a href="#2-JoinPoint细节" class="headerlink" title="2.JoinPoint细节"></a>2.JoinPoint细节</h3><ul><li><p>概述</p><blockquote><p>切入点表达式通常都会是从宏观上定位一组方法，和具体某个通知的注解结合起<br>来就能够确定对应的连接点。那么就一个具体的连接点而言，我们可能会关心这<br>个连接点的一些具体信息，例如：当前连接点所在方法的方法名、当前传入的参<br>数值等等。这些信息都封装在 JoinPoint 接口的实例对象中。</p></blockquote></li><li><p>图示</p></li></ul><p><img src="https://s1.ax1x.com/2020/08/24/dyN0fK.png" srcset="/img/loading.gif" alt="pic"></p><hr><h2 id="3-通知（Advice）"><a href="#3-通知（Advice）" class="headerlink" title="3.通知（Advice）"></a>3.通知（Advice）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><code>在具体的连接点上要执行的操作。</code></li><li><code>一个切面可以包括一个或者多个通知。</code></li><li><code>通知所使用的注解的值往往是切入点表达式。</code></li></ul><h3 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h3><ul><li><code>前置通知：在方法执行之前执行的通知</code></li><li><code>使用@Before 注解</code></li></ul><h3 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h3><ul><li><code>后置通知：后置通知是在连接点完成之后执行的，即连接点返回结果或者抛出异常的时候</code></li><li><code>使用@After 注解</code></li></ul><h3 id="返回通知"><a href="#返回通知" class="headerlink" title="返回通知"></a>返回通知</h3><ul><li><p><code>返回通知：无论连接点是正常返回还是抛出异常，后置通知都会执行。如果只想在连接点返回的时候记录日志，应使用返回通知代替后置通知。</code></p></li><li><p><code>使用@AfterReturning 注解</code></p></li><li><p><code>在返回通知中访问连接点的返回值</code></p><ol><li>在返回通知中，只要将 returning 属性添加到@AfterReturning 注解中，就<br>可以访问连接点的返回值。</li><li>该属性的值即为用来传入返回值的参数名称必须在通知方法的签名中添加一个同名参数。在运行时 Spring AOP 会通过这个参数传递返回值</li><li>原始的切点表达式需要出现在 pointcut 属性中</li></ol></li></ul><h3 id="异常通知"><a href="#异常通知" class="headerlink" title="异常通知"></a>异常通知</h3><ul><li><code>异常通知：只在连接点抛出异常时才执行异常通知</code></li><li><code>将 throwing 属性添加到@AfterThrowing 注解中，也可以访问连接点抛出的异常。Throwable 是所有错误和异常类的顶级父类，所以在异常通知方法可以捕获到任何错误和异常。</code></li><li><code>如果只对某种特殊的异常类型感兴趣，可以将参数声明为其他异常的参数类型。然后通知就只在抛出这个类型及其子类的异常时才被执行</code></li></ul><p><img src="https://s1.ax1x.com/2020/08/25/dgRWJf.png" srcset="/img/loading.gif" alt="pic"></p><h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><ul><li><code>环绕通知是所有通知类型中功能最为强大的，能够全面地控制连接点，甚至可以控制是否执行连接点。</code></li><li><code>对于环绕通知来说，连接点的参数类型必须是 ProceedingJoinPoint。它是JoinPoint 的子接口，允许控制何时执行，是否执行连接点。</code></li><li><code>在环绕通知中需要明确调用 ProceedingJoinPoint 的 proceed()方法来执行被代理的方法。如果忘记这样做就会导致通知被执行了，但目标方法没有被执行。</code></li><li><code>注意：环绕通知的方法需要返回目标方法执行之后的结果，即调用joinPoint.proceed();的返回值，否则会出现空指针异常。</code></li></ul><p><img src="https://s1.ax1x.com/2020/08/25/dgRIyQ.png" srcset="/img/loading.gif" alt="pic"></p><h3 id="重用切入点定义"><a href="#重用切入点定义" class="headerlink" title="重用切入点定义"></a>重用切入点定义</h3><ul><li><code>同一个切点表达式可能会在多个通知中重复出现。</code></li><li><code>定义重用切入点表达式，即可让其他通知可以通过方法名称引入该切入点</code></li></ul><p><img src="https://s1.ax1x.com/2020/08/24/dyNwY6.png" srcset="/img/loading.gif" alt="pic"></p><h3 id="指定切面的优先级"><a href="#指定切面的优先级" class="headerlink" title="指定切面的优先级"></a>指定切面的优先级</h3><ul><li><code>在同一个连接点上应用不止一个切面时，除非明确指定，否则它们的优先级是不确定的。</code></li><li><code>切面的优先级可以通过实现 Ordered 接口或利用@Order 注解指定。</code></li><li><code>实现 Ordered 接口，getOrder()方法的返回值越小，优先级越高。</code></li><li><code>若使用@Order 注解，序号出现在注解中</code></li></ul><p><img src="https://s1.ax1x.com/2020/08/24/dyNdFx.png" srcset="/img/loading.gif" alt="pic"></p><hr>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法/数据结构模板</title>
    <link href="/2020/08/20/%E6%9C%80%E8%BF%91%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/08/20/%E6%9C%80%E8%BF%91%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><h2 id="6-哈夫曼编码实现"><a href="#6-哈夫曼编码实现" class="headerlink" title="6.哈夫曼编码实现"></a>6.哈夫曼编码实现</h2><p>哈夫曼编码思想：让一串流中出现次数多的字符，它的哈夫曼编码位数少，反之，位数则大。同时，保证不含某一个字符的Huffman-code是另外一个字符的Huffman-code的前缀。<br>具体的晚上补充。</p><p><strong><em>贴上例题</em></strong></p><p><a href="https://www.nowcoder.com/practice/c471efdbd33a4a979539a91170c9f1cb?tpId=128&&tqId=33774&rp=1&ru=/ta/exam-meituan&qru=/ta/exam-meituan/question-ranking" target="_blank" rel="noopener">字符编码</a></p><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">string</span> s;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; s) &#123;        sort(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());        priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; pq;        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(), i, j;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; ) &#123;            <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>; j&lt;n; j++) &#123;                <span class="hljs-keyword">if</span>(s[j] != s[i]) &#123;                    pq.push(j-i);                    i = j;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(j==n) &#123;                pq.push(j-i);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) &#123;            ans = pq.top();        &#125;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(pq.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">int</span> a = pq.top(); pq.pop();            <span class="hljs-keyword">int</span> b = pq.top(); pq.pop();            sum = a + b;            ans += sum;            pq.push(sum);        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">"\n"</span>;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-并查集"><a href="#5-并查集" class="headerlink" title="5.并查集"></a>5.并查集</h2><p>并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。</p><ul><li><p>Java模板</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">UnionFindSet</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] parents_;  <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] ranks_;   <span class="hljs-keyword">public</span> UnionFindSet(<span class="hljs-built_in">int</span> n) &#123;      parents_ = new <span class="hljs-built_in">int</span>[n + <span class="hljs-number">1</span>];      ranks_ = new <span class="hljs-built_in">int</span>[n + <span class="hljs-number">1</span>];      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; parents_.length; ++i) &#123;          parents_[i] = i;          ranks_[i] = <span class="hljs-number">1</span>;      &#125;  &#125;  <span class="hljs-comment">// 联合两个集合</span>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean Union(<span class="hljs-built_in">int</span> u, <span class="hljs-built_in">int</span> v) &#123;      <span class="hljs-built_in">int</span> pu = Find(u);      <span class="hljs-built_in">int</span> pv = Find(v);      <span class="hljs-keyword">if</span> (pu == pv) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;       <span class="hljs-keyword">if</span> (ranks_[pv] &gt; ranks_[pu])          parents_[pu] = pv;                 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ranks_[pu] &gt; ranks_[pv])          parents_[pv] = pu;      <span class="hljs-keyword">else</span> &#123;          parents_[pv] = pu;          ranks_[pu] += <span class="hljs-number">1</span>;      &#125;       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-comment">// 查询u的顶级祖先节点</span>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Find(<span class="hljs-built_in">int</span> u) &#123;      <span class="hljs-keyword">while</span> (parents_[u] != u) &#123;          parents_[u] = parents_[parents_[u]];          u = parents_[u];      &#125;      <span class="hljs-keyword">return</span> u;  &#125;&#125;</code></pre></li><li><p>C++模板</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFindSet</span> &#123;</span><span class="hljs-keyword">public</span>:    UnionFindSet(<span class="hljs-keyword">int</span> n) &#123;        ranks_ = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);                parents_ = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);                                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parents_.<span class="hljs-built_in">size</span>(); ++i)            parents_[i] = i;    &#125;        <span class="hljs-comment">// Merge sets that contains u and v.</span>    <span class="hljs-comment">// Return true if merged, false if u and v are already in one set.</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;        <span class="hljs-keyword">int</span> pu = Find(u);        <span class="hljs-keyword">int</span> pv = Find(v);        <span class="hljs-keyword">if</span> (pu == pv) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-comment">// Meger low rank tree into high rank tree</span>        <span class="hljs-keyword">if</span> (ranks_[pv] &lt; ranks_[pu])            parents_[pv] = pu;                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ranks_[pu] &lt; ranks_[pv])            parents_[pu] = pv;        <span class="hljs-keyword">else</span> &#123;            parents_[pv] = pu;            ranks_[pu] += <span class="hljs-number">1</span>;        &#125;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;        <span class="hljs-comment">// Get the root of u.</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;                <span class="hljs-comment">// Compress the path during traversal</span>        <span class="hljs-keyword">if</span> (u != parents_[u])            parents_[u] = Find(parents_[u]);                <span class="hljs-keyword">return</span> parents_[u];    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; parents_;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ranks_;&#125;;</code></pre></li></ul><h2 id="4-树状数组"><a href="#4-树状数组" class="headerlink" title="4.树状数组"></a>4.树状数组</h2><pre><code class="hljs angelscript"><span class="hljs-comment">// 具体的细节，后续补发</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">NumArray</span> &#123;    <span class="hljs-built_in">int</span>[] c;    <span class="hljs-keyword">public</span> NumArray(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> n = nums.length;        c = new <span class="hljs-built_in">int</span>[n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;            update(i, nums[i]);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> lowbit(<span class="hljs-built_in">int</span> x) &#123;        <span class="hljs-keyword">return</span> x &amp; (-x);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> update(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> val) &#123;        x++;        <span class="hljs-built_in">int</span> n = c.length;        <span class="hljs-built_in">int</span> ov = query(x) - query(x<span class="hljs-number">-1</span>);        <span class="hljs-keyword">while</span>(x &lt; n) &#123;            c[x] += (val - ov);            x += lowbit(x);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> query(<span class="hljs-built_in">int</span> x) &#123;        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>) &#123;            res += c[x];            x -= lowbit(x);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> sumRange(<span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;        i++; j++;        <span class="hljs-keyword">return</span> query(j) - query(i<span class="hljs-number">-1</span>);    &#125;&#125;</code></pre><h2 id="3-差分"><a href="#3-差分" class="headerlink" title="3.差分"></a>3.差分</h2><pre><code class="hljs css"><span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[]</span>为一个<span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[]</span>差分数组, 其定义为<span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[i]</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[i-1]</span>具体的，后续补发。</code></pre><h2 id="2-前缀和"><a href="#2-前缀和" class="headerlink" title="2.前缀和"></a>2.前缀和</h2><pre><code class="hljs angelscript"><span class="hljs-comment">// 快速求出a数组中某一段的区间和</span><span class="hljs-comment">// sum [i, j] -&gt; prefix[j] - prefix[i-1]</span><span class="hljs-comment">// int n = a.length</span><span class="hljs-built_in">int</span>[] prefix = new <span class="hljs-built_in">int</span>[n+<span class="hljs-number">1</span>];<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;prefix[i] = a[i<span class="hljs-number">-1</span>] + prefix[i<span class="hljs-number">-1</span>]&#125;</code></pre><h2 id="1-字典树"><a href="#1-字典树" class="headerlink" title="1.字典树"></a>1.字典树</h2><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment">Trie字典树模板</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> &#123;</span><span class="hljs-keyword">char</span> c;<span class="hljs-keyword">boolean</span> <span class="hljs-built_in">end</span>;Map&lt;Character, Node&gt; children;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">char</span> _c)</span> </span>&#123;c = _c;children = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();&#125;&#125;Node root;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;root = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'#'</span>);&#125;        <span class="hljs-comment">// 构建Trie树</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;Node p = root;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;p.children.putIfAbsent(c, <span class="hljs-keyword">new</span> Node(c));p = p.children.<span class="hljs-built_in">get</span>(c);&#125;p.<span class="hljs-built_in">end</span> = <span class="hljs-literal">true</span>;&#125;        <span class="hljs-comment">// 查询是否存在匹配串</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;Node p = root;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;Node son = p.children.<span class="hljs-built_in">get</span>(c);<span class="hljs-keyword">if</span>(son==null) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;p = son;&#125;<span class="hljs-keyword">return</span> p.<span class="hljs-built_in">end</span>;&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo admin plugin~</title>
    <link href="/2020/08/18/hexo-amin-pluin%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/08/18/hexo-amin-pluin%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo-admin-plugin"><a href="#hexo-admin-plugin" class="headerlink" title="hexo admin plugin"></a>hexo admin plugin</h1><h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><pre><code class="hljs gauss"><span class="hljs-comment">// cnpm 是 npm 的国内镜像（淘宝），访问下载速度快很多</span>cnpm install --<span class="hljs-keyword">save</span> hexo-admin</code></pre><h2 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h2><pre><code class="hljs routeros">hexo<span class="hljs-built_in"> server </span>-d</code></pre><h2 id="访问在线编辑视窗"><a href="#访问在线编辑视窗" class="headerlink" title="访问在线编辑视窗"></a>访问在线编辑视窗</h2><pre><code class="hljs dts"><span class="hljs-comment">// 本地hexo博客地址 + admin即可</span><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:4000/admin</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础（三）AOP</title>
    <link href="/2020/08/12/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89AOP/"/>
    <url>/2020/08/12/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="1-AOP-前奏"><a href="#1-AOP-前奏" class="headerlink" title="1 AOP 前奏"></a>1 AOP 前奏</h2><h3 id="1-1-引子"><a href="#1-1-引子" class="headerlink" title="1.1 引子"></a>1.1 引子</h3><blockquote><p>数学计算器</p><p>要求 :<br> ①执行加减乘除运算<br> ②日志：在程序执行期间追踪正在发生的活动<br> ③验证：希望计算器只能处理正数的运算</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/12/ajn5TJ.png" srcset="/img/loading.gif" alt="数学计算器"></p><h3 id="1-2-实现方式"><a href="#1-2-实现方式" class="headerlink" title="1.2 实现方式"></a>1.2 实现方式</h3><ol><li><p>常规实现<br>在各个方法体中，直接插入代码（硬编码方式）</p><p>可想而知，这种方式，容易造成代码混乱、代码分散，之后编码越发复制，维护成本逐渐变大。</p></li><li><p>动态代理</p></li></ol><blockquote><p>代理设计模式的原理：</p><p>使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p><p>代理对象，可以实现对目标方法功能上的增强操作。从而可以不用硬编码的方式，就可以添加日志功能。</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/12/ajKEgx.png" srcset="/img/loading.gif" alt="日志代理"></p><p>值得一提的是，Spring的AOP技术来源就是动态代理技术，不过动态代理相对来说，编码还是稍微有些难的，而Spring的AOP技术，操作起来就很简单。</p><hr><h2 id="2-AOP-概述"><a href="#2-AOP-概述" class="headerlink" title="2 AOP 概述"></a>2 AOP 概述</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>●AOP(Aspect-Oriented Programming， 面向切面编程)：是一种新的方法论，是对传统<br>OOP(Object-Oriented Programming，面向对象编程)的补充。</p><p>●AOP 编程操作的主要对象是切面(aspect)，而切面 模块化横切关注点。</p><p>●在应用 AOP 编程时，仍然需要定义公共功能，但可以明确的定义这个功能应用在哪<br>里，以什么方式应用，并且不必修改受影响的类。这样一来横切关注点就被模块化到特<br>殊的类里——这样的类我们通常称之为“切面”。</p><p>●AOP 的好处：</p><blockquote><p>o 每个事物逻辑位于一个位置，代码不分散，便于维护和升级<br>o 业务模块更简洁，只包含核心业务代码</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/12/ajKOde.png" srcset="/img/loading.gif" alt="数学计算器AOP"></p><h3 id="2-2-AOP-术语"><a href="#2-2-AOP-术语" class="headerlink" title="2.2 AOP 术语"></a>2.2 AOP 术语</h3><ul><li><p>横切关注点<br>从每个方法中抽取出来的同一类非核心业务。</p></li><li><p>切面(Aspect)<br>封装横切关注点信息的类，每个关注点体现为一个通知方法。</p></li><li><p>通知(Advice)<br>切面必须要完成的各个具体工作</p></li><li><p>目标(Target)<br>被通知的对象</p></li><li><p>代理(Proxy)<br>向目标对象应用通知之后创建的代理对象</p></li><li><p>连接点(Joinpoint)<br>横切关注点在程序代码中的具体体现，对应程序执行的某个特定位置。<br>例如：类某个方法调用前、调用后、方法捕获到异常后等。<br>在应用程序中可以使用横纵两个坐标来定位一个具体的连接点：<br><img src="https://s1.ax1x.com/2020/08/12/ajMhm8.png" srcset="/img/loading.gif" alt="连接点"></p></li><li><p>切入点(pointcut)：<br>定位连接点的方式。每个类的方法中都包含多个连接点，所以连接点是类中客观 存在的事物。</p></li></ul><blockquote><p>如果把连接点看作数据库中的记录，那么切入点就是查询条件 —— AOP 可 以 通 过 切 入 点 定 位 到 特 定 的 连 接 点 。</p></blockquote><h3 id="2-3-AspectJ"><a href="#2-3-AspectJ" class="headerlink" title="2.3 AspectJ"></a>2.3 AspectJ</h3><blockquote><p>AspectJ：Java 社区里最完整最流行的 AOP 框架。<br>在 Spring2.0 以上版本中，可以使用基于 AspectJ 注解或基于 XML 配置的 AOP。</p></blockquote><ol><li>在 Spring 中启用 AspectJ 注解支持</li></ol><p>导入 JAR 包</p><pre><code class="hljs css">● <span class="hljs-selector-tag">aopalliance</span><span class="hljs-selector-class">.jar</span>● <span class="hljs-selector-tag">aspectj</span><span class="hljs-selector-class">.weaver</span><span class="hljs-selector-class">.jar</span>● <span class="hljs-selector-tag">spring-aspects</span><span class="hljs-selector-class">.jar</span></code></pre><p>引入 aop 名称空间<br><img src="https://s1.ax1x.com/2020/08/12/ajQf3R.png" srcset="/img/loading.gif" alt="aop名称空间"></p><p>配置注解驱动</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>&gt;</span><span class="hljs-comment">&lt;!-- 当 Spring IOC 容器侦测到 bean 配置文件中的&lt;aop:aspectj-autoproxy&gt;元素时，</span><span class="hljs-comment">会自动为与 AspectJ 切面匹配的 bean 创建代理 --&gt;</span></code></pre><p>用 AspectJ 注解声明切面</p><blockquote><p>①要在 Spring 中声明 AspectJ 切面，只需要在 IOC 容器中将切面声明为 bean 实例。 </p><p>②当在 Spring IOC容器中初始化 AspectJ 切面之后，Spring IOC 容器就会为那些与 AspectJ 切面相匹配的<br>bean 创建代理。 </p><p>③在AspectJ 注解中，切面只是一个带有@Aspect 注解的 Java 类，它往往要包含很 多通知。 </p><p>④通知是标注有某种注解的简单的Java 方法。</p></blockquote><ul><li><p>AspectJ 支持 5 种类型的通知注解：</p><pre><code class="hljs less"><span class="hljs-variable">@Before</span>：前置通知，在方法执行之前执行<span class="hljs-variable">@After</span>：后置通知，在方法执行之后执行<span class="hljs-variable">@AfterRunning</span>：返回通知，在方法返回结果之后执行<span class="hljs-variable">@AfterThrowing</span>：返回通知，在方法抛出异常之后执行<span class="hljs-variable">@Around</span>：环绕通知，围绕着方法执行 (环绕通知就相当于一个动态代理， 具有上面注解的所有功能)</code></pre></li><li><p>动态代理处理日志<br>通常的，我们在为某个方法添加日志操作时，使用动态代理会有：</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 动态代理的invoke方法 --&gt;</span></span><span class="xml">try </span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">    // 前置通知（或前置增强）</span><span class="hljs-template-variable">    目标方法执行</span><span class="hljs-template-variable">    // 返回通知</span><span class="hljs-template-variable">&#125;</span><span class="xml"> catch(Exception e)</span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">    // 返回通知</span><span class="hljs-template-variable">&#125;</span><span class="xml"> finally </span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">    // 后置通知</span><span class="hljs-template-variable">&#125;</span></code></pre></li><li><p>使用AspectJ注解实现日志<br>定义切面类<br><img src="https://s1.ax1x.com/2020/08/12/aj1x78.png" srcset="/img/loading.gif" alt="切面类"></p></li></ul><blockquote><p>通过Spring AOP实现日志（不止日志）就显得十分简单了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础（二）IOC</title>
    <link href="/2020/08/07/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89IOC/"/>
    <url>/2020/08/07/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89IOC/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC容器及Bean的配置"><a href="#IOC容器及Bean的配置" class="headerlink" title="IOC容器及Bean的配置"></a>IOC容器及Bean的配置</h1><h2 id="1-IOC和DI"><a href="#1-IOC和DI" class="headerlink" title="1 IOC和DI"></a>1 IOC和DI</h2><h3 id="1-1-IOC-Inversion-of-Control-：-反转控制。"><a href="#1-1-IOC-Inversion-of-Control-：-反转控制。" class="headerlink" title="1.1 IOC(Inversion of Control)： 反转控制。"></a>1.1 IOC(Inversion of Control)： 反转控制。</h3><blockquote><p>在应用程序中的组件需要获取资源时，传统的方式是组件主动的从容器中获取所需<br>要的资源，在这样的模式下开发人员往往需要知道在具体容器中特定资源的获取方式，<br>增加了学习成本，同时降低了开发效率。<br>反转控制的思想完全颠覆了应用程序组件获取资源的传统方式：反转了资源的获取<br>方向——改由容器主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创<br>建资源对象的，只需要提供接收资源的方式即可，极大的降低了学习成本，提高了开发<br>的效率。这种行为也称为查找的被动形式。</p></blockquote><h3 id="1-2-DI-Dependency-Injection-：-依赖注入。"><a href="#1-2-DI-Dependency-Injection-：-依赖注入。" class="headerlink" title="1.2 DI(Dependency Injection)： 依赖注入。"></a>1.2 DI(Dependency Injection)： 依赖注入。</h3><blockquote><p>IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如：setter 方法)接受<br>来自于容器的资源注入。相对于 IOC 而言，这种表述更直接。</p></blockquote><h3 id="1-3-IOC-容器在-Spring-中的实现"><a href="#1-3-IOC-容器在-Spring-中的实现" class="headerlink" title="1.3 IOC 容器在 Spring 中的实现"></a>1.3 IOC 容器在 Spring 中的实现</h3><blockquote><p>[1]在通过 IOC 容器读取 Bean 的实例之前，需要先将 IOC 容器本身实例化。<br>[2]Spring 提供了 IOC 容器的两种实现方式</p><blockquote><p>(1)BeanFactory：IOC 容器的基本实现，是 Spring 内部的基础设施，是面向 Spring<br>本身的，不是提供给开发人员使用的。<br>(2)ApplicationContext：BeanFactory 的子接口，提供了更多高级特性。面向 Spring<br>的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</p></blockquote></blockquote><p><img src="https://s1.ax1x.com/2020/08/12/ajA7WT.png" srcset="/img/loading.gif" alt="ApplicationContext"></p><h3 id="1-4-ApplicationContext-的主要实现类"><a href="#1-4-ApplicationContext-的主要实现类" class="headerlink" title="1.4 ApplicationContext 的主要实现类"></a>1.4 ApplicationContext 的主要实现类</h3><p>[1]ClassPathXmlApplicationContext：对应类路径下的 XML 格式的配置文件</p><p>[2]FileSystemXmlApplicationContext：对应文件系统中的 XML 格式的配置文件</p><p>[3]在初始化时就创建单例的 bean，也可以通过配置的方式指定创建的 Bean 是多实<br>例的。</p><h3 id="1-5-ConfigurableApplicationContext"><a href="#1-5-ConfigurableApplicationContext" class="headerlink" title="1.5 ConfigurableApplicationContext"></a>1.5 ConfigurableApplicationContext</h3><p>[1]是 ApplicationContext 的子接口，包含一些扩展方法</p><p>[2]refresh()和 close()让 ApplicationContext 具有启动、关闭和刷新上下文的能力。</p><h3 id="1-6-WebApplicationContext"><a href="#1-6-WebApplicationContext" class="headerlink" title="1.6 WebApplicationContext"></a>1.6 WebApplicationContext</h3><p>专门为 WEB 应用而准备的，它允许从相对于 WEB 根目录的路径中完成初始化工作</p><hr><h2 id="2-通过类型获取-bean"><a href="#2-通过类型获取-bean" class="headerlink" title="2 通过类型获取 bean"></a>2 通过类型获取 bean</h2><p>从 IOC 容器中获取 bean 时，可以通过 bean 的类型获取。<br>但如果同一个类型的 bean 在 XML 文件中配置了多个，则获取时会抛出异常，所以同一个类型的 bean 在容器中必须是唯一的。</p><pre><code class="hljs coffeescript">HelloWorld helloWorld = ioc.getBean(HelloWorld. <span class="hljs-class"><span class="hljs-keyword">class</span>);</span></code></pre><h2 id="3-给-bean-的属性赋值"><a href="#3-给-bean-的属性赋值" class="headerlink" title="3 给 bean 的属性赋值"></a>3 给 bean 的属性赋值</h2><h3 id="3-1-赋值的途经"><a href="#3-1-赋值的途经" class="headerlink" title="3.1 赋值的途经"></a>3.1 赋值的途经</h3><p>①通过 bean 的 setXxx()方法赋值</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Book"</span> &gt;</span><span class="hljs-comment">&lt;!-- property赋值方式，是通过Book的Setter方法实现的 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"studentId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1001"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>②通过 bean 的构造器赋值</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Book"</span> &gt;</span><span class="hljs-comment">&lt;!-- Book中得有一个对应参数的构造器声明 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>= <span class="hljs-string">"10010"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>= <span class="hljs-string">"Book01"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>= <span class="hljs-string">"Author01"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>= <span class="hljs-string">"20.2"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span> &gt;</span></code></pre><p>特别的，对于这种方式，我们还可以</p><ul><li>通过索引值指定参数位置<pre><code class="hljs pgsql">&lt;bean id="book" <span class="hljs-keyword">class</span>="com.kyrie.entity.Book" &gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "10010" <span class="hljs-keyword">index</span> ="0"/&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "Book01" <span class="hljs-keyword">index</span> ="1"/&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "Author01" <span class="hljs-keyword">index</span> ="2"/&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "20.2" <span class="hljs-keyword">index</span> ="3"/&gt;&lt;/bean &gt;</code></pre></li></ul><ul><li>通过类型不同区分重载的构造器<pre><code class="hljs pgsql">&lt;bean id="book" <span class="hljs-keyword">class</span>="com.kyrie.entity.Book" &gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "10010" <span class="hljs-keyword">index</span> ="0" <span class="hljs-keyword">type</span>="java.lang.Integer" /&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "Book01" <span class="hljs-keyword">index</span> ="1" <span class="hljs-keyword">type</span>="java.lang.String" /&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "Author01" <span class="hljs-keyword">index</span> ="2" <span class="hljs-keyword">type</span>="java.lang.String" /&gt;    &lt;constructor-arg <span class="hljs-keyword">value</span>= "20.2" <span class="hljs-keyword">index</span> ="3" <span class="hljs-keyword">type</span>="java.lang.Double" /&gt;&lt;/bean &gt;</code></pre></li></ul><p>③给 bean 的级联属性赋值</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"action"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.bean.Action"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"service"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"service"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 设置级联属性(了解) --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"service.dao.dataSource"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"DBCP"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>④p 名称空间</p><blockquote><p>为了简化 XML 文件的配置，越来越多的 XML 文件采用属性而非子元素配置信息。<br>Spring 从 2.5 版本开始引入了一个新的 p 命名空间，可以通过<bean>元素属性的方式配置 Bean 的属性。<br>使用 p 命名空间后，基于 XML 的配置方式将进一步简化。</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这种方式是将内部标签 转成了 属性 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span></span><span class="hljs-tag"><span class="hljs-attr">id</span>=<span class="hljs-string">"studentSuper"</span></span><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"com.atguigu.helloworld.bean.Student"</span></span><span class="hljs-tag"><span class="hljs-attr">p:studentId</span>=<span class="hljs-string">"2002"</span> <span class="hljs-attr">p:stuName</span>=<span class="hljs-string">"Jerry2016"</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">"18"</span> /&gt;</span></code></pre><h3 id="3-2-赋值时可以使用的值"><a href="#3-2-赋值时可以使用的值" class="headerlink" title="3.2 赋值时可以使用的值"></a>3.2 赋值时可以使用的值</h3><p>①字面量</p><blockquote><p>[1]可以使用字符串表示的值，可以通过 value 属性或 value 子节点的方式指定<br>[2]基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式<br>[3]若字面值中包含特殊字符，可以使用<![CDATA[]]>把字面值包裹起来</p></blockquote><p>②null 值</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 如果需要赋值为null，则可以使用&lt;null&gt;标签 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>= <span class="hljs-string">"bookName"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></code></pre><p>③外部已声明的 bean</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shop"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Shop"</span> &gt;</span><span class="hljs-comment">&lt;!-- ref引用--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>= <span class="hljs-string">"book"</span> <span class="hljs-attr">ref</span> =<span class="hljs-string">"book"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span> &gt;</span></code></pre><p>④内部 bean</p><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">"shop2"</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"com.kyrie.entity.Shop"</span> &gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>= <span class="hljs-string">"book"</span>&gt;    &lt;bean <span class="hljs-built_in">class</span>= <span class="hljs-string">"com.kyrie.entity.Book"</span> &gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>= <span class="hljs-string">"bookId"</span> value =<span class="hljs-string">"1000"</span>/&gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>= <span class="hljs-string">"bookName"</span> value=<span class="hljs-string">"innerBook"</span> /&gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>= <span class="hljs-string">"author"</span> value=<span class="hljs-string">"innerAuthor"</span> /&gt;    &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>= <span class="hljs-string">"price"</span> value =<span class="hljs-string">"50"</span>/&gt;    &lt;/bean&gt;    &lt;/<span class="hljs-keyword">property</span>&gt;&lt;/bean &gt;</code></pre><p>注意：</p><ul><li><p>内部 bean 不能使用在任何其他地方</p></li><li><p>当 bean 实例仅仅给一个特定的属性使用时，可以将其声明为内部 bean。内部bean 声明直接包含在<property>或<constructor-arg>元素里，不需要设置任何 id或 name 属性</p></li></ul><h3 id="3-3-集合属性赋值"><a href="#3-3-集合属性赋值" class="headerlink" title="3.3 集合属性赋值"></a>3.3 集合属性赋值</h3><p>在 Spring 中可以通过一组内置的 XML 标签来配置集合属性，例如：<list>，<set><br>或<map>。</p><p>①数组和 List</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shop"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Shop"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>= <span class="hljs-string">"categoryList"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 以字面量为值的 List 集合 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> 历史<span class="hljs-tag">&lt;/<span class="hljs-name">value</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span> 军事<span class="hljs-tag">&lt;/<span class="hljs-name">value</span> &gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>= <span class="hljs-string">"bookList"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 以 bean 的引用为值的 List 集合 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>= <span class="hljs-string">"book01"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>= <span class="hljs-string">"book02"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span> &gt;</span></code></pre><p>配置 java.util.Set 需要使用<set>标签，定义的方法与 List 一样。</p><p>②Map</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cup"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Cup"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"bookMap"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>bookKey01<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book01"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>bookKey02<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book02"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>③Properties<br>使用<props>定义 java.util.Properties，该标签使用多个<prop>作为子标签。每个<prop>标签必须定义 key 属性</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.atguigu.spring.bean.DataSource"</span></span><span class="hljs-tag"><span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"properties"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"userName"</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"password"</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"url"</span>&gt;</span>jdbc:mysql:///test<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>④集合类型的 bean</p><blockquote><p>如果只能将集合对象配置在某个 bean 内部，则这个集合的配置将不能重用。<br>我们需要将集合 bean 的配置拿到外面，供其他 bean 引用。</p></blockquote><p>配置集合类型的 bean 需要引入 util 名称空间</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bookList"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book01"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book02"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book03"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book04"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"book05"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"categoryList"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>编程<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>极客<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>相声<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>评书<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span></code></pre><hr><h2 id="4-通过工厂创建-bean"><a href="#4-通过工厂创建-bean" class="headerlink" title="4 通过工厂创建 bean"></a>4 通过工厂创建 bean</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://s1.ax1x.com/2020/08/12/ajEF6e.png" srcset="/img/loading.gif" alt="FactoryBean"></h2><h2 id="5-bean-的高级配置"><a href="#5-bean-的高级配置" class="headerlink" title="5 bean 的高级配置"></a>5 bean 的高级配置</h2><h3 id="5-1-配置信息的继承"><a href="#5-1-配置信息的继承" class="headerlink" title="5.1 配置信息的继承"></a>5.1 配置信息的继承</h3><p>①背景<br>查看下面两个 Employee 的配置，其中 dept 属性是重复的。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dept"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Department"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"deptId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"100"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"deptName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"IT"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emp01"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Employee"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1001"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Tom"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"20"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 重复的属性值 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"detp"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dept"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emp02"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Employee"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1002"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Jerry"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"25"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 重复的属性值 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"detp"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dept"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>②配置信息的继承</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 以emp01作为父bean，继承后可以省略公共属性值的配置 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emp02"</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"emp01"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1002"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Jerry"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"25"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>Note：</p><ul><li>Spring 允许继承 bean 的配置，被继承的 bean 称为父 bean。继承这个父 bean<br>的 bean 称为子 bean。</li><li>子 bean 从父 bean 中继承配置，包括 bean 的属性配置。</li><li>子 bean 也可以覆盖从父 bean 继承过来的配置</li></ul><p>③补充说明</p><ol><li>父 bean 可以作为配置模板，也可以作为 bean 实例。若只想把父 bean 作为模<br>板，可以设置<bean>的 abstract 属性为 true，这样 Spring 将不会实例化这个 bean。</li><li>如果一个 bean 的 class 属性没有指定，则必须是抽象 bean。</li><li>并不是<bean>元素里的所有属性都会被继承。比如：autowire，abstract 等。 也可以忽略父 bean 的 class<br>属性，让子 bean 指定自己的类，而共享相同的属 性配置。但此时 abstract 必须设为 true。</li></ol><h3 id="5-2-bean-之间的依赖"><a href="#5-2-bean-之间的依赖" class="headerlink" title="5.2 bean 之间的依赖"></a>5.2 bean 之间的依赖</h3><p>有的时候创建一个 bean 的时候需要保证另外一个 bean 也被创建，这时我们称前<br>面的 bean 对后面的 bean 有依赖。</p><p>这里需要注意的是依赖关系不等于引用关系，只是一种前后关系。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- depends-on: 此时emp03在dept后在IOC容器中创建 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"emp03"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.kyrie.entity.Employee"</span></span><span class="hljs-tag"><span class="hljs-attr">depends-on</span>=<span class="hljs-string">"dept"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1003"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"empName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Kate"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"21"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h3 id="5-3-bean-的作用域"><a href="#5-3-bean-的作用域" class="headerlink" title="5.3 bean 的作用域"></a>5.3 bean 的作用域</h3><p>在 Spring 中，可以在<bean>元素的 scope 属性里设置 bean 的作用域，以决定<br>这个 bean 是单实例的还是多实例的。</p><blockquote><p>默认情况下，Spring 只为每个在 IOC 容器里声明的 bean 创建唯一一个实例，<br>整个 IOC 容器范围内都能共享该实例：<br>所有后续的 getBean()调用和 bean 引用都将返回这个唯一的 bean 实例。该作用域被称为 singleton，它是所有 bean 的默认作用域。</p></blockquote><p>当 bean 的作用域为单例时，Spring 会在 IOC 容器对象创建时就创建 bean 的对<br>象实例。而当 bean 的作用域为 prototype 时，IOC 容器在获取 bean 的实例时创建<br>bean 的实例对象。</p><p><img src="https://s1.ax1x.com/2020/08/12/ajAvwR.png" srcset="/img/loading.gif" alt="bean生命周期"></p><h3 id="5-4-bean-的生命周期"><a href="#5-4-bean-的生命周期" class="headerlink" title="5.4 bean 的生命周期"></a>5.4 bean 的生命周期</h3><h3 id="5-5-引用外部属性文件"><a href="#5-5-引用外部属性文件" class="headerlink" title="5.5 引用外部属性文件"></a>5.5 引用外部属性文件</h3><blockquote><p>当 bean 的配置信息逐渐增多时，查找和修改一些 bean 的配置信息就变得愈加困<br>难。这时可以将一部分信息提取到 bean 配置文件的外部，以 properties 格式的属<br>性文件保存起来，同时在 bean 的配置文件中引用 properties 属性文件中的内容，<br>从而实现一部分属性值在发生变化时仅修改 properties 属性文件即可。这种技术<br>多用于连接数据库的基本信息的配置。</p></blockquote><p>①直接配置</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 直接配置 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql:///test"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>②创建 properties 属性文件</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- jdbc.properties --&gt;</span>prop.userName=rootprop.password=rootprop.url=jdbc:mysql:///testprop.driverClass=com.mysql.jdbc.Driver</code></pre><p>③引入 context 名称空间</p><blockquote><p>在头文件中，引入该名称空间<br>这个在eclipse中需要自行操作， IDEA中自动可用。</p></blockquote><p><img src="https://s1.ax1x.com/2020/08/12/ajAxT1.png" srcset="/img/loading.gif" alt="context名称空间"></p><p>④指定 properties 属性文件的位置</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Spring配置文件中 --&gt;</span><span class="hljs-comment">&lt;!-- 指定properties属性文件的位置 --&gt;</span><span class="hljs-comment">&lt;!-- classpath:xxx 表示属性文件位于类路径下 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:jdbc.properties"</span>/&gt;</span></code></pre><p>⑤从 properties 属性文件中引入属性值</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 从properties属性文件中引入属性值 --&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span></span></span><span class="xml">class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;prop.userName&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;prop.password&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;prop.url&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$</span></span></span><span class="hljs-template-variable">&#123;prop.driverClass&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span>/&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span></code></pre><h3 id="5-6-自动装配"><a href="#5-6-自动装配" class="headerlink" title="5.6 自动装配"></a>5.6 自动装配</h3><p>①自动装配的概念</p><blockquote><p>[1]手动装配：以 value 或 ref 的方式 明确指定属性值都是手动装配。<br>[2]自动装配：根据指定的装配规则， 不需要明确指定，Spring 自动将匹配的<br>属性值入 注入 bean 中。</p></blockquote><p>②装配模式</p><blockquote><p>[1]根据 类型自动装配：将类型匹配的 bean 作为属性注入到另一个 bean 中。 若 IOC 容器中有多个与目标 bean 类型一致的<br>bean，Spring 将无法判定哪个 bean 最合适该属性，所以不能执行自动装配</p><p>[2]根据 名称自动装配：必须将目标 bean 的名称和属性名设置的完全相同</p><p>[3]通过构造器自动装配：当 bean 中存在多个构造器时，此种自动装配方式 将会很复杂。不推荐使用。</p></blockquote><p>③选用建议</p><blockquote><p>相对于使用注解的方式实现的自动装配，在 XML 文档中进行的自动装配略显<br>笨拙，在项目中更多的使用<strong>注解</strong>的方式实现。</p></blockquote><hr><h2 id="6-通过注解配置-bean"><a href="#6-通过注解配置-bean" class="headerlink" title="6 通过注解配置 bean"></a>6 通过注解配置 bean</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><blockquote><p>相对于 XML 方式而言，通过注解的方式配置 bean 更加简洁和优雅，而且和 MVC<br>组件化开发的理念十分契合，是开发中常用的使用方式。</p></blockquote><h3 id="6-2-Spring相关注解"><a href="#6-2-Spring相关注解" class="headerlink" title="6.2 Spring相关注解"></a>6.2 Spring相关注解</h3><blockquote><p>①普通组件：@Component 标识一个受 Spring IOC 容器管理的组件</p><p>②持久化层组件：@Respository 标识一个受 Spring IOC 容器管理的持久化层组件</p><p>③业务逻辑层组件：@Service 标识一个受 Spring IOC 容器管理的业务逻辑层组件</p><p>④表述层控制器组件：@Controller 标识一个受 Spring IOC 容器管理的表述层控制器组件</p><p>⑤组件命名规则 [1]默认情况：使用组件的简单类名首字母小写后得到的字符串作为 bean 的 id [2]使用组件注解的 value<br>属性指定 bean 的 id</p></blockquote><p>Note: 事实上 Spring 并没有能力识别一个组件到底是不是它所标记的类型。换言之，每一个注解在Spring看来是一个样，这些不同的注解，主要针对阅读程序的人来说。</p><h3 id="6-3-Spring注解扫描"><a href="#6-3-Spring注解扫描" class="headerlink" title="6.3 Spring注解扫描"></a>6.3 Spring注解扫描</h3><p>组件被上述注解标识后还需要通过 Spring 进行扫描才能够侦测到。</p><ol><li><p>指定被扫描的 package</p><pre><code class="hljs vhdl">&lt;<span class="hljs-keyword">context</span>:<span class="hljs-keyword">component</span>-scan base-<span class="hljs-keyword">package</span>=<span class="hljs-string">"com.krismile.component"</span>/&gt;</code></pre></li><li><p>细节说明</p></li></ol><blockquote><p>[1]base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基 类包及其子包中的所有类。</p><p>[2]当需要扫描多个包时可以使用逗号分隔。</p><p>[3]包含与排除, <a href="context:include-filter">context:include-filter</a>子节点表示要包含的目标类,<br><a href="context:exclude-filter">context:exclude-filter</a>子节点表示要排除在外的目标类</p><p>[4]如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属 性过滤特定的类，示例：</p></blockquote><pre><code class="hljs xml">context:component-scan    base-package="com.krismile.component"    <span class="hljs-comment">&lt;!--  --&gt;</span>    resource-pattern="autowire/*.class"/&gt;</code></pre><p>Note: 如果是导入jar包的开发方式，需要额外导入 spring-aop-4.0.0.RELEASE.jar。</p><h3 id="6-4-组件装配"><a href="#6-4-组件装配" class="headerlink" title="6.4 组件装配"></a>6.4 组件装配</h3><blockquote><p>Controller 组件中往往需要用到 Service 组件的实例，Service 组件中往往需要用<br>到 Repository 组件的实例。Spring 可以通过注解的方式帮我们实现属性的装配。</p></blockquote><p>顺便一说： 在指定要扫描的包时，<a href="context:component-scan">context:component-scan</a> 元素会自动注册一个 bean的后置处理器：AutowiredAnnotationBeanPostProcessor的实例。该后置处理器可以自动装配标记了@Autowired、@Resource 或@Inject 注解的属性。</p><ol><li><p>@Autowired 注解</p><blockquote><p>根据类型实现自动装配 (先根据类型找， 再根据变量名即id找)<br>默认情况下，当 IOC 容器里存在多个类型兼容的 bean 时，Spring 会尝试匹<br>配 bean 的 id 值是否与变量名相同，如果相同则进行装配。如果 bean 的 id 值不相同，通过类型的自动装配将无法工作。</p></blockquote></li><li><p>@Resource 注解</p><blockquote><p>@Resource 注解要求提供一个 bean 名称的属性，若该属性为空，则自动采用 标注处的变量或方法名作为 bean 的名称。</p></blockquote></li><li><p>@Inject</p><blockquote><p>@Inject 和@Autowired 注解一样也是按类型注入匹配的 bean，但没有 reqired 属性。</p></blockquote></li></ol><hr><h2 id="7-整合多个配置文件"><a href="#7-整合多个配置文件" class="headerlink" title="7 整合多个配置文件"></a>7 整合多个配置文件</h2><ol><li><p>Spring 允许通过<import>将多个配置文件引入到一个文件中，进行配置文件的集成。 这样在启动 Spring容器时，仅需要指定这个合并好的配置文件就可以。</p></li><li><p>import 元素的 resource 属性支持 Spring 的标准的路径资源<br><img src="https://s1.ax1x.com/2020/08/12/ajEV0A.png" srcset="/img/loading.gif" alt="整合外部文件"></p></li></ol><h2 id="8-泛型依赖注入"><a href="#8-泛型依赖注入" class="headerlink" title="8 泛型依赖注入"></a>8 泛型依赖注入</h2><p>coding…</p><hr>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础（一）概述</title>
    <link href="/2020/08/05/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/08/05/Spring%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><h2 id="1-Spring-概述"><a href="#1-Spring-概述" class="headerlink" title="1 Spring 概述"></a>1 Spring 概述</h2><p>①Spring 是一个开源框架</p><p>②Spring 为简化企业级开发而生，使用 Spring，JavaBean 就可以实现很多以前要靠 EJB<br>才能实现的功能。同样的功能，在 EJB 中要通过繁琐的配置和复杂的代码才能够实现，而在<br>Spring 中却非常的优雅和简洁。</p><p>③Spring 是一个 <strong><em>IOC(DI)</em></strong>和 <strong><em>AOP</em></strong> 容器框架。(<strong><em>控制反转</em></strong> &amp;&amp; <strong><em>面向切面编程</em></strong>)</p><p>④Spring 的优良特性</p><blockquote><p>[1] 非侵入式：基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API<br>[2] 依赖注入：DI——Dependency Injection，反转控制(IOC)最经典的实现。<br>[3] 面向切面编程：Aspect Oriented Programming——AOP<br>[4] 容器：Spring 是一个容器，因为它包含并且管理应用对象的生命周期<br>[5] 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。<br>[6] 一站式：在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第<br>三方类库（实际上 Spring 自身也提供了表述层的 SpringMVC 和持久层的 Spring JDBC）。</p></blockquote><p>⑤Spring 目前的版本<br>缺图，待补</p><p>⑥Spring 模块<br>缺图，待补</p><h2 id="2-搭建-Spring-运行时环境"><a href="#2-搭建-Spring-运行时环境" class="headerlink" title="2 搭建 Spring 运行时环境"></a>2 搭建 Spring 运行时环境</h2><p>搭建Spring运行环境，有两种方式 — 大多数的环境搭建都如此。</p><h3 id="2-1-导入jar包方式"><a href="#2-1-导入jar包方式" class="headerlink" title="2.1 导入jar包方式"></a>2.1 导入jar包方式</h3><p>①加入 JAR 包</p><pre><code class="hljs css"><span class="hljs-selector-attr">[1]</span><span class="hljs-selector-tag">Spring</span> 自身 <span class="hljs-selector-tag">JAR</span> 包：<span class="hljs-selector-tag">spring-framework-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span>\<span class="hljs-selector-tag">libs</span> 目录下<span class="hljs-selector-tag">spring-beans-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-context-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-core-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-tag">spring-expression-4</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.RELEASE</span><span class="hljs-selector-class">.jar</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-tag">commons-logging-1</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.jar</span></code></pre><blockquote><p>注意的是：你所需要导入的jar包需要根据实际需要来导入。换言之，你应该要了解Spring各个模块所需的jar包都是哪些。 Spring模块图见上文。</p></blockquote><p>②根据需要创建 Spring 配置文件</p><h3 id="2-2-Maven导入依赖"><a href="#2-2-Maven导入依赖" class="headerlink" title="2.2 Maven导入依赖"></a>2.2 Maven导入依赖</h3><p>Maven是一种项目管理工具，具体做的事就是：从’本地仓库’ 或 ‘远程仓库’中导入所需要的依赖坐标。这里所说的’依赖坐标’就是相关jar包的坐标，只需导入坐标的好处是可以降低程序臃肿程度，jar包就只用一份就可。</p><p>代码示例：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入spring-core依赖 --&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="3-Spring-HelloWorld"><a href="#3-Spring-HelloWorld" class="headerlink" title="3 Spring HelloWorld"></a>3 Spring HelloWorld</h2><p>一般的，学习一门编程语言，总是会以编写出HelloWorld代码来简单入门。<br>不失一般性，这里将以Spring HelloWorld方式来简单入门。</p><blockquote><p>①目标：使用 Spring 创建对象，为属性赋值<br>②创建 Student 类</p></blockquote><pre><code class="hljs angelscript"><span class="hljs-comment">// Student.java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> &#123;    <span class="hljs-keyword">private</span> Integer studentId;    <span class="hljs-keyword">private</span> String stuName;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;    <span class="hljs-comment">// 省略getter/setter/toString</span>&#125;</code></pre><blockquote><p>③创建 Spring 配置文件</p></blockquote><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring配置文件,这里命名为helloworld.xml --&gt;</span><span class="hljs-comment">&lt;!-- 名字命名无强制要求，这里为了突出意图，以此命名 --&gt;</span><span class="hljs-comment">&lt;!-- 使用bean元素定义一个由IOC容器创建的对象 --&gt;</span><span class="hljs-comment">&lt;!-- class属性指定用于创建bean的全类名 --&gt;</span><span class="hljs-comment">&lt;!-- id属性指定用于引用bean实例的标识 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"student"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.atguigu.helloworld.bean.Student"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 使用property子元素为bean的属性赋值 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"studentId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1001"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"stuName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Tom2015"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"20"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><blockquote><p>④测试：通过 Spring 的 IOC 容器创建 Student 类实例</p></blockquote><pre><code class="hljs arduino"><span class="hljs-comment">// junit测试类 - 测试方法</span>@Test<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//1.创建IOC容器对象</span>    ApplicationContext iocContainer = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"helloworld.xml"</span>);    <span class="hljs-comment">//2.根据id值获取bean实例对象</span>    Student student = (Student) iocContainer.getBean(<span class="hljs-string">"student"</span>);    <span class="hljs-comment">//3.打印bean</span>    System.out.<span class="hljs-built_in">println</span>(student);&#125;</code></pre><blockquote><p>⑤验证：Spring 在创建 IOC 容器对象时，就已经完成了 bean 的创建和属性的赋值。</p></blockquote><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><p>Spring框架相当于是一个容器，所有的类一旦被Spring容器管理起来，就不用我们去操心这些类的其一系列事情。<br>我们需要做的就是放心的将这些类交由Spring容器管理，然后舒舒服服的享受Spring带给我们的便利。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSM</tag>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Test001</title>
    <link href="/2020/07/28/My-Test001/"/>
    <url>/2020/07/28/My-Test001/</url>
    
    <content type="html"><![CDATA[<h2 id="第一个标题"><a href="#第一个标题" class="headerlink" title="第一个标题"></a>第一个标题</h2><h3 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h3><p><img src="/img/yql.jpg" srcset="/img/loading.gif" alt="岳绮罗"></p><hr><h2 id="第二个标题"><a href="#第二个标题" class="headerlink" title="第二个标题"></a>第二个标题</h2><p><img src="/img/avatar001.png" srcset="/img/loading.gif" alt="犇"></p><hr><h2 id="写到这儿"><a href="#写到这儿" class="headerlink" title="写到这儿"></a>写到这儿</h2><hr>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo如何添加分类和标签</title>
    <link href="/2020/07/28/Hexo%E5%8D%9A%E5%AE%A2-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/"/>
    <url>/2020/07/28/Hexo%E5%8D%9A%E5%AE%A2-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-文章分类"><a href="#1-文章分类" class="headerlink" title="1. 文章分类"></a>1. 文章分类</h1><h2 id="1-1-生成分类目录"><a href="#1-1-生成分类目录" class="headerlink" title="1.1 生成分类目录"></a>1.1 生成分类目录</h2><pre><code class="hljs routeros">hexo new<span class="hljs-built_in"> page </span>categories</code></pre><p>生成目录之后，会在根目录的source目录中多出一个categories目录。</p><h2 id="1-2-分类配置"><a href="#1-2-分类配置" class="headerlink" title="1.2 分类配置"></a>1.2 分类配置</h2><p>在categories目录中有一个index.md文件，在文件中添加type: categories</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">分类</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">categories</span><span class="hljs-meta">---</span></code></pre><h2 id="1-3-增加多个分类"><a href="#1-3-增加多个分类" class="headerlink" title="1.3 增加多个分类"></a>1.3 增加多个分类</h2><p>在categories目录中有一个index.md文件，复制多份就可以了</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">分类一</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">categories</span><span class="hljs-meta">---</span><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">分类二</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">categories</span><span class="hljs-meta">---</span></code></pre><h2 id="1-4-给文章添加”分类”属性"><a href="#1-4-给文章添加”分类”属性" class="headerlink" title="1.4 给文章添加”分类”属性"></a>1.4 给文章添加”分类”属性</h2><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">categories:</span> <span class="hljs-string">分类</span><span class="hljs-meta">---</span></code></pre><p>文章分类属性只能存在一个，如果写了多个，只有第一个会启效果</p><h1 id="2-文章标签"><a href="#2-文章标签" class="headerlink" title="2. 文章标签"></a>2. 文章标签</h1><h2 id="2-1-生成标签目录"><a href="#2-1-生成标签目录" class="headerlink" title="2.1 生成标签目录"></a>2.1 生成标签目录</h2><pre><code class="hljs routeros">hexo new<span class="hljs-built_in"> page </span>tags</code></pre><p>生成目录之后，会在根目录的source目录中多出一个tags目录。</p><h2 id="2-2-标签配置"><a href="#2-2-标签配置" class="headerlink" title="2.2 标签配置"></a>2.2 标签配置</h2><p>在tags目录中有一个index.md文件，在文件中添加type: tags</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">标签</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">tags</span><span class="hljs-meta">---</span></code></pre><h2 id="2-3-增加多个标签"><a href="#2-3-增加多个标签" class="headerlink" title="2.3 增加多个标签"></a>2.3 增加多个标签</h2><p>在tags目录中有一个index.md文件，复制多份就可以了</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">标签一</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">tags</span><span class="hljs-meta">---</span><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">标签二</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">type:</span> <span class="hljs-string">tags</span><span class="hljs-meta">---</span></code></pre><h2 id="2-4-给文章添加”标签”属性"><a href="#2-4-给文章添加”标签”属性" class="headerlink" title="2.4 给文章添加”标签”属性"></a>2.4 给文章添加”标签”属性</h2><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><span class="hljs-attr">date:</span> <span class="hljs-number">2020</span><span class="hljs-number">-02</span><span class="hljs-number">-10</span> <span class="hljs-number">14</span><span class="hljs-string">:47:40</span><span class="hljs-attr">categories:</span> <span class="hljs-string">分类</span><span class="hljs-attr">tags:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签一</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签二</span><span class="hljs-meta">---</span></code></pre><p>文章标签属性可存在多个</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
